\documentclass[english,a4paper, 10pt, smallheadings, DIV12]{scrartcl}
\usepackage[T1]{fontenc}
\usepackage[utf8x]{inputenc}
\setlength{\parskip}{\medskipamount}
\setlength{\parindent}{0pt}
\usepackage{color}
\usepackage{babel}

\usepackage{array}
\usepackage{textcomp}
\usepackage{url}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage[numbers]{natbib}
\usepackage[unicode=true,
 bookmarks=true,bookmarksnumbered=false,bookmarksopen=false,
 breaklinks=false,pdfborder={0 0 1},backref=false,colorlinks=true]
 {hyperref}
\hypersetup{pdftitle={Baselinebelow},
 pdfauthor={C. Beleites},
 pdfsubject={Vignette on hyperSpec's baselinebelow data set},
 pdfkeywords={hyperSpec, baselinebelow}}
\usepackage{hyphenat}

\makeatletter

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Text class specific LaTeX commands.
\usepackage{Sweave}

\newcommand{\Rcode}[1]{\texorpdfstring{\nohyphens{\texttt{#1}}}{#1}}
\newcommand{\Robject}[1]{\texorpdfstring{\nohyphens{\texttt{#1}}}{#1}}
\newcommand{\Rcommand}[1]{\texorpdfstring{\nohyphens{\texttt{#1}}}{#1}}
\newcommand{\Rfunction}[1]{\texorpdfstring{\nohyphens{\texttt{#1}}}{#1}}

\newcommand{\Rfunarg}[1]{\texorpdfstring{\nohyphens{\textit{#1}}}{#1}}
\newcommand{\Rpackage}[1]{\texorpdfstring{\nohyphens{\textit{#1}}}{#1}}
\newcommand{\Rmethod}[1]{\texorpdfstring{\nohyphens{\textit{#1}}}{#1}}
\newcommand{\Rclass}[1]{\texorpdfstring{\nohyphens{\textit{#1}}}{#1}}

\newcommand{\mFun}[1]{\marginpar{\scriptsize \Rfunction{#1}}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User specified LaTeX commands.
% Meta information - fill between {} and do not remove %
% \VignetteIndexEntry{baselinebelow }
% \VignetteKeywords{hyperspec, baselinebelow}
% \VignettePackage{hyperSpec}
\AtBeginDocument{
  	\setlength{\parskip}{\medskipamount}
	\setlength{\parindent}{0pt}
   \fvset{listparameters={\setlength{\topsep}{0pt}}}
   \renewenvironment{Schunk}{\vspace{\topsep}\begin{small}}{\end{small}\vspace{\topsep}
   }
\SweaveOpts{pgf = FALSE, eps = FALSE, external = FALSE, pdf = TRUE, keep.source = TRUE, strip.white = TRUE}
}

% my preferred
\usepackage{xspace}

\usepackage{hyphenat}
\usepackage{fancyvrb}

%\newcommand{\rcm}[1]{\ensuremath{#1\;\mathrm{cm^{-1}}}\xspace}
%\newcommand{\code}[1]{\nohyphens{\texttt{#1}}\xspace}
\newcommand{\R}{\texorpdfstring{\texttt{R}}{R}\xspace}

\@ifundefined{showcaptionsetup}{}{%
 \PassOptionsToPackage{caption=false}{subfig}}
\usepackage{subfig}
\makeatother

\begin{document}

\title{Fitting Polynomial Baselines to Complete Spectra}

\author{Claudia Beleites (\url{cbeleites@units.it})\\
CENMAT, DMRN, University of Trieste}

\maketitle


\newcommand{\rcm}[1]{#1\,cm\textsuperscript{-1}\xspace}
%\newcommand{\code}[1]{\nohyphens{\texttt{#1}}\xspace}
<<startup, echo = FALSE>>=
options(SweaveHooks=list(fig=function() par(mar = c (3.6, 3.6, .6, .6), family="serif")))
options ("width" = 90)
@


\newlength{\tmplength}

\subsection*{Syntax \& parameters}
\settowidth{\tmplength}{\Rcode{spc.fit.poly.below (}}
\Rcode{spc.fit.poly.below (fit.to, apply.to = fit.to, poly.order = 1, npts.min = NULL,\\
\hspace*{\tmplength}noise = 0, short = NULL, user = NULL, date = NULL)}
\begin{labeling}{\Rcode{poly.order}:~~~}
\item[\Rfunction{fit.to}:] \Robject{hyperSpec} object with the spectra whose baselines are to be fitted.
\item[\Rfunction{apply.to}:] \Robject{hyperSpec} object giving the spectral range, on which the baselines should be evaluated.\\
 If \Rfunction{apply} is \Rcode{NULL}, a \Robject{hyperSpec} object with the polynomial coefficients is returned
 instead of evaluated baselines.
\item[\Rfunction{poly.order}:] polynomial order of the baselines
\item[\Rfunction{npts.min}:] minimal number of data points per spectrum to be used for the fit.\\
\Rfunction{npts.min} defaults to the smaller of 3 times (\Rfunction{poly.order} + 1) or
$\frac{1}{20th}$ of the number of data points per spectrum.\\
If \Rfunction{npts.min} $\leq$ {poly.order}, a warning is issued and \Rcode{npts.min <- poly.order + 1} is used.
 \item[\Rcode{noise}:] a vector giving the amount of noise, see below.
 \item[\Rcode{short}, \Rcode{user}, \Rcode{date}:] are handed to \Rcode{logentry}
 \end{labeling}

<<init, echo = FALSE, results = hide>>=
	library (hyperSpec)
	library (colorspace)
@
\subsection*{Specifying the spectral range}
<<trace, echo = FALSE, results = hide>>=
	trace (spc.fit.poly.below, quote ({ls ();
	plot (fit.to[,, use.old], col = cl, add = TRUE, lines.args = list (pch = pch, type = "p"), zeroline = NULL);
	}), at = 10, print = FALSE)
@
<<figspcrange, fig=TRUE, pdf = TRUE, echo = FALSE, results = hide, eps = FALSE, width = 8, height = 4, include = FALSE>>=
plot (chondro [3,,1700 ~ 1750], plot.args = list (ylim = range (chondro [3,,1700 ~ 1750]) + c(-50, 0)))
cl <- "black"
pch = 1
bl <- spc.fit.poly.below (chondro [3,,1700 ~ 1750], NULL, poly.order = 1)
pch = 20
plot (chondro [3,,1720 ~ 1750], col = "blue", add = TRUE, lines.args = list (lwd = 2))
abline (bl[[]], col = "black")
cl <- "blue"
bl <- spc.fit.poly.below (chondro [3,,1720 ~ 1750], NULL, poly.order = 1)
abline (bl[[]], col = "blue")
@
<<trace2, echo = FALSE, results = hide>>=
	trace (spc.fit.poly.below, quote ({ls ();
	plot (fit.to[,, use.old], col = cl, add = TRUE, lines.args = list (pch = pch, type = "p"), zeroline = NULL);
	lines (fit.to@wavelength, bl, col = cl);
	}), at = 10, print = FALSE)
@
\begin{figure}[b]
\begin{center}
\includegraphics[width = .5\textwidth]{baselinebelow-figspcrange}
\caption{Influence of \Rcode{fit.to} on the baseline polynomial. The black baseline is fit to the spectral range \rcm{1700 -- 1800},
the blue to \rcm{1715 -- 1800} only (dots \& circles: supporting points).}
\label{fig:spectralrange}
\end{center}
\end{figure}

The polynomials are always fit to \Rcode{fit.to}, but are evaluated on the the wavelengths of \Rcode{apply.to}.
Therefore it is possible to exclude spectral regions that do not contribute to
the baseline from the fitting, while the baseline is used for the whole
spectrum.
The choice of the spectral range in \Rcode{fit.to} influences the resulting baselines to a certain extent, as becomes clear
from figure~\ref{fig:spectralrange}.
Narrowing the spectral range in \Rcode{fit.to} speeds up the fitting of the
polynomials:
<<fit-apply>>=
system.time (spc.fit.poly.below (chondro[], NULL, poly.order = 1, npts.min = 20,
            noise = 12))
system.time (spc.fit.poly.below (chondro [,, c (min ~ 700, 1700 ~ max)],
				NULL, poly.order = 1, npts.min = 20, noise = 12))
@

\subsection*{Fitting  polynomials of different orders}
<<figorder, fig=TRUE, pdf = TRUE, echo = FALSE, results = hide, eps = FALSE, width = 12, height = 4, include = FALSE>>=
plot (chondro [1], lines.args = list (type = "n"))
cols <- c ("black", "blue", "#008000", "red")
for (o in 0 : 3){
		cl <- cols [o + 1]
		bl <- spc.fit.poly.below (chondro [1], poly.order = o)
	}
	plot (chondro [1], add = TRUE)
@
\begin{figure}[t]
\begin{center}
\includegraphics[width = .75\textwidth]{baselinebelow-figorder}
\caption{Baseline polynomial fit to the first spectrum of the chondro data set of order
0 (black), 1 (blue), 2 (green), and 3 (red). The dots indicate the points used for the fitting of the polynomial.}
\label{fig:order}
\end{center}
\end{figure}
Figure~\ref{fig:order} shows the resulting baseline polynomial of
\Rcode{spc.fit.poly.below (chondro [1], poly.order = order)}
with \Rcode{order} $=$ 0 to 3 for the first spectrum of the chondro data set.

\subsection*{The mechanisms of fitting the baselines}
Appropriate spectral regions with supporting points for the baseline polynomials are calculated iteratively:
\begin{enumerate}
\item A polynomial of the requested order is fit to the considered spectral range.
\item Only the parts of the spectrum that lie below this polynomial plus the \Rcode{noise} are retained as supporting points for
the next iteration.
\end{enumerate}
These two steps are repeated until either
\begin{itemize}
\item no further points are excluded, or
\item the next polynomial would have less than \Rcode{npts.min} supporting points.
\end{itemize}
The baselines and respective supporting points for each iteration of
\Rcode{spc.fit.poly.below (chondro [1], poly.order = 1)}
are shown in figure~\ref{fig:iter}.

<<fig1, fig=TRUE, pdf = TRUE, echo = FALSE, results = hide, eps = FALSE, width = 12, height = 4, include = FALSE>>=
cols <- as (HSV(seq (240, 0, length.out = 9), 1, 1), "RGB")
cols@coords [,2] <- cols@coords[,2] / 2
cols <- hex (cols)

bl <- chondro [1] + 1
plot (chondro [1])
npts <- numeric (length (cols))
for (iter in seq_along (cols)){
	npts [iter] <- sum (chondro [[1]] < bl [[]])
	cl <- cols [iter]
	text (750, max (chondro [1]), paste ("Iter. ", iter, ": ", npts [iter], " support pts.", sep = ""),
			 pos = 1, col = cols [iter], offset = iter - 1)
	bl <- spc.fit.poly.below (chondro [1], poly.order = 1, npts.min = npts[iter]  - 1)
}
plot (chondro [1], add = TRUE)
@
<<fig2, fig=TRUE, pdf = TRUE, echo = FALSE, results = hide, eps = FALSE, width = 12, height = 2.5, include = FALSE>>=
bl <- chondro [1] + 1
plot (chondro [1], plot.args = list (ylim = range (chondro [1,, c(600 ~ 650, 1730 ~ 1800)])))
for (iter in seq_along (cols)){
	npts <- sum (chondro [[1]] < bl [[]])
	cl <- cols [iter]
	#cat ("Iteration", iter, ":", npts, "supporting points\n")
	bl <- spc.fit.poly.below (chondro [1], poly.order = 1, npts.min = npts - 1)
}
plot (chondro [1], add = TRUE)
@
\begin{figure}[bh]
\begin{center}
  \includegraphics[width=.75\textwidth]{baselinebelow-fig1}
  \includegraphics[width=.75\textwidth]{baselinebelow-fig2}
  \caption{Iterative fitting of the baseline. The dots give the supporting points for the baselines in the same colour.
  The lower part is a magnification of the intensity axis.}
  \label{fig:iter}
\end{center}
\end{figure}

\subsection*{The noise level}
<<fig3, fig=TRUE, pdf = TRUE, echo = FALSE, results = hide, eps = FALSE, width = 8, height = 3, include = FALSE>>=

spc <- new ("hyperSpec", spc = matrix (rnorm (30, mean = 100, sd = 2), ncol = 30))
noise <- 10
plot (spc)
trace (spc.fit.poly.below, quote ({
					plot (fit.to[,, use.old], col = cl, add = TRUE, lines.args = list (pch = 20, type = "p"), zeroline = NULL);
					lines (fit.to@wavelength, bl, col = cl);
					lines (fit.to@wavelength, bl + noise, col = cl, lty = 2)
				}), at = 10, print = FALSE)

cols <- as (HSV(seq (240, 0, length.out = 2), 1, 1), "RGB")
cols@coords [,2] <- cols@coords[,2] / 2
cols <- hex (cols)

bl <- spc + 15
for (iter in seq_along (cols)){
	npts <- sum (spc [[]] < (bl [[]] + noise))
	cl <- cols [iter]
	bl <- spc.fit.poly.below (spc, poly.order = 0, npts.min = npts, noise = noise)
	text (5, max (spc[]), paste ("Iter. ", iter, ": ", npts, " support pts.", sep = ""),
			pos = 1, col = cols [iter], offset = iter - 1)
}
cl <- "black"
trace (spc.fit.poly.below, quote ({
					plot (fit.to[,, use.old], col = cl, add = TRUE, lines.args = list (type = "p"), zeroline = NULL);
					lines (fit.to@wavelength, bl, col = cl);
				}), at = 10, print = FALSE)
bl <- spc.fit.poly.below (spc, poly.order = 0)
@
<<fig4, fig=TRUE, pdf = TRUE, echo = FALSE, results = hide, eps = FALSE, width = 12, height = 4, include = FALSE>>=
trace (spc.fit.poly.below, quote ({
					plot (fit.to[,, use.old], col = cl, add = TRUE, lines.args = list (pch = 20, type = "p"), zeroline = NULL);
					lines (fit.to@wavelength, bl, col = cl);
					lines (fit.to@wavelength, bl + noise, col = cl, lty = 2)
				}), at = 10, print = FALSE)
cols <- as (HSV(seq (240, 0, length.out = 10), 1, 1), "RGB")
cols@coords [,2] <- cols@coords[,2] / 2
cols <- hex (cols)
bl <- chondro [1] + 15
plot (chondro [1])
for (iter in seq_along (cols)){
	npts <- sum (chondro [[1]] < bl [[]] + noise)
	cl <- cols [iter]
	text (750, max (chondro [1]), paste ("Iter. ", iter, ": ", npts, " support pts.", sep = ""),
			pos = 1, offset = iter-1, col = cols [iter])
	bl <- spc.fit.poly.below (chondro [1], poly.order = 1, npts.min = npts - 1, noise = noise)
}
plot (chondro [1], add = TRUE)
@
<<fig5, fig=TRUE, pdf = TRUE, echo = FALSE, results = hide, eps = FALSE, width = 12, height = 2.5, include = FALSE>>=
trace (spc.fit.poly.below, quote ({
					plot (fit.to[,, use.old], col = cl, add = TRUE, lines.args = list (pch = 20, type = "p"));
					lines (fit.to@wavelength, bl, col = cl);
					lines (fit.to@wavelength, bl + noise, col = cl, lty = 2)
				}), at = 10, print = FALSE)
cols <- as (HSV(seq (240, 0, length.out = 10), 1, 1), "RGB")
cols@coords [,2] <- cols@coords[,2] / 2
cols <- hex (cols)
bl <- chondro [1] + 15
plot (chondro [1], plot.args = list (ylim = range (chondro [1,, c(600 ~ 650, 1730 ~ 1800)])))
for (iter in seq_along (cols)){
	npts <- sum (chondro [[1]] < bl [[]] + noise)
	cl <- cols [iter]
	cat ("Iteration", iter, ":", npts, "supporting points\n")
	bl <- spc.fit.poly.below (chondro [1], poly.order = 1, npts.min = npts - 1, noise = noise)
}
plot (chondro [1], add = TRUE)
untrace (spc.fit.poly.below)
@
\begin{figure}[t]
\begin{center}
  \includegraphics[width=.5\textwidth]{baselinebelow-fig3}
  \includegraphics[width=.75\textwidth]{baselinebelow-fig4}
  \includegraphics[width=.75\textwidth]{baselinebelow-fig5}
  \caption{Iterative fitting of the baseline with noise level. Upper part: effects of the noise parameter on the baseline
  of a spectrum consisting only of noise and offset:  without giving \Rcode{noise} the resulting baseline
  (black) is clearly too low. A noise level of 10 results in the red baseline.
  The middle and lower part show the baseline fitting with noise level on the
  complete spectrum.
  Colour: iterations, dots/circles: supporting points for the respective baselines. Dashed: baseline plus noise. All points above this line are excluded from the next iteration.
}
  \label{fig:noise}
\end{center}
\end{figure}

Besides defining a minimal number of supporting points, a ``noise level'' may be given.
Consider a spectral range consisting only of noise.
The upper part of figure~\ref{fig:noise} illustrates the problem. As the baseline fitting algorithm cannot distinguish
between noise and real bands appearing above the fitted polynomial, the resulting baseline (black) is too low if the \Rcode{noise}
parameter is not given.

Setting the noise level to \Sexpr{noise} (2 standard deviations), the fitting converges immediately with a much better result.
The resulting baselines for
\Rcode{spc.fit.poly.below (chondro [1], poly.order = 1, noise = 12)}
of the whole spectrum are shown in the middle and lower part of figure~\ref{fig:noise}

\Rcode{noise} may be a single value for all spectra, or a vector with the noise level for each of the spectra separately.

<<cleanup, echo = FALSE, results = hide>>=
rm (list = ls () ) 
@ 
\end{document}
