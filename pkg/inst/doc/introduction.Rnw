% -*- mode: noweb; noweb-default-code-mode: R-mode; -*- 
\documentclass[english, a4paper, 10pt, headings=small, DIV11]{scrartcl}
\usepackage{longtable}

\SweaveInput{vignettes.defs}
\hypersetup{pdftitle={hyperSpec Introduction},
 pdfauthor={C. Beleites},
 pdfsubject={Introduction on the R package hyperSpec},
 pdfkeywords={hyperSpec}}

% \VignetteIndexEntry{hyperSpec Introduction}
% \VignetteKeywords{hyperspec}
% \VignettePackage{hyperSpec}

\begin{document}
\title{\Rpackage{hyperSpec} Introduction }
\maketitle
\warnbox{Revision}{This document is currently undergoing an extensive revision prior to the next release on CRAN.}
\warnbox{Reproducing the Examples in this Vignette}{
All spectra used in this manual are installed automatically with \phy. 

% The source data files of the \Robject{flu} and \Robject{laser} data sets as well as of the 
%  paracetamol spectrum are shipped with the package.
% For reproducing the examples in a live session, the full file names of the 
% spectra can be found with the command:\\
% \texttt{\small\textsl{> Sys.glob (paste (.libPaths (),
% "hyperSpec/doc/rawdata/*.txt", sep = "/"))}} \\
Note that some definitions are executed in \texttt{vignette.defs}.

% The source data file of the \Robject{chondro} data, however, needs to be be obtained separately. It % is available for download as a .zip file at \Rpackage{hyperSpec}'s home page  
% (\url{http://r-forge.r-project.org/projects/hyperspec/}, ca. 8.5 MB).
% The original file (ca. 31 MB) is far too large to be included in the package.
}

\tableofcontents{}

\section{Introduction}

\Rpackage{hyperSpec} is a R package that allows convenient handling
of (hyper)spectral data sets, \ie data sets comprising spectra
together with further data on a per-spectrum basis. The
spectra can be anything that is recorded over a common discretized
axis, the \emph{so-called} wavelength axis. Throughout the documentation of the package,
the terms intensity and wavelength refer to the spectral ordinate
and abscissa, respectively.

However, \Rpackage{hyperSpec} works perfectly fine with any data
that fits in that general scheme, so that the three terms may also
be used for:
\begin{labeling}{wavelength: }
\item [wavelength:] frequency, wavenumbers, chemical shift, Raman shift,
$\frac{m}{z}$, etc.
\item [intensity:] transmission, absorbance, $\frac{e^{-}}{s}$, \textellipsis
\item [extra~data: \hfill] spatial information (spectral images, maps, or profiles),
temporal information (kinetics, time series), concentrations (calibration
series), class membership information, etc. \\
Note that there is no restriction on the number of extra data columns.
\end{labeling}
This vignette gives an introduction on basic working techniques using
the R package \Rpackage{hyperSpec}. It comes with five data sets,
\begin{labeling}{wavelength: }
\item [\Robject{chondro}] a Raman map of chondrocytes in cartilage,
\item [\Robject{flu}] a set of fluorescence spectra of a calibration
series, and
\item [\Robject{laser}] a time series of an unstable laser emission
\item [\Robject{paracetamol}] a Raman spectrum of paracetamol (acetaminophen) ranging from 100 to 3200\,cm\textsuperscript{-1} with some overlapping wavelength ranges. \\ It is used mainly in the \emph{plotting} vignette.
  \item [\Robject{barbituates}] GC-MS spectra with differing wavelength axes as a list of
    \Sexpr{length (barbituates)} \chy objects.
\end{labeling}
In this vignette, the data sets are used to illustrate appropriate procedures for different tasks and different spectra.

In addition, the first three data sets are accompanied by vignetted that show exemplary work flows for the respective data type.

This document describes how to accomplish spectroscopic tasks. It does not give a complete reference on particular functions. It is therefore recommended to look up the methods in R's help system using  \Rcode{?{} command}.

After some remarks on the notation used in the document and on the general behaviour of R, sections~\ref{sec:loading-package} shows how to load the package. Section~\ref{sec:structure-chy} describes how \chy objects are organized internally. 

A list of all functions available in \phy is given in appendix~\ref{tab:functions}~(\pageref{tab:functions})


\subsection{Notation}

This vignette demonstrates working techniques mostly from a spectroscopic
point of view: rather than going through the functions provided by
\Rpackage{hyperSpec}, it is organized more closely on spectroscopic
tasks. However, the functions discussed are printed on the margin
for a fast overview.

In R, slots of a S4 class can be accessed directly by the \Rcommand{@}
operator. In this vignette, the notation \Rcode{@xxx} will thus mean
\emph{``slot xxx of an object''} see figure~\ref{fig:structure} on page~\pageref{fig:structure}).
%TODO vref

Likewise, named elements of a \Rclass{list}, like the columns of
a \Rclass{data.frame}, are accessed by the \Rcode{\$} operator,
and \Rcode{\$xxx} will be used for \emph{``column xxx''}, and
as an abbreviation for \emph{``column xxx of the data.frame in slot
data of the object''} see figure~\ref{fig:structure} on page~\pageref{fig:structure}) .%TODO vref


\section{Remarks on R}


\subsection{Generic Functions}

\emph{Generic Functions} are functions that apply to a wide range
of data types or classes, e.\,g. \Rmethod{plot}, \Rmethod{print},
mathematical operators, etc. These functions can be implemented in
a specialized way by each class.

\Rclass{hyperSpec} implements with a variety of such functions, see
table~\ref{tab:generic} on page~\pageref{tab:generic}.

\subsection{Functionality Can be Extended at Runtime}
 \R's  concept of functions offers much flexibility. Functions may be added or changed by the user in his \emph{workspace} at any time. This is also true for methods belonging to a certain class.
Neither restart of R nor reloading of the package or anything the like is needed. If the original function resides in a namespace (as it is the case for all functions in \phy), the original function is not deleted. It is just masked by the user's new function but stays accessible via the \Rcode{::} operator.

This offers the opportunity of easily writing specialized functions that are adapted to specific tasks. 

For examples, see the setup of the lattice plotting functions in the \texttt{vignettes.defs} file accompanying all \phy vignettes.

\subsection{Validity Checking}
S4 classes have a mechanism to define and enforce that the data actually stored in the object is appropriate for this class. In other words, there is a mechanism of \emph{validity checking}. 

The functions provided by \Rpackage{hyperSpec} check the validity of \Rclass{hyperSpec} objects at the beginning, and --- if the validity could be broken by inappropriate arguments --- also before leaving the function.
 
It is highly recommended to use validity checking also for user-defined functions. In addition, non-generic functions should first ensure that the argument actually is a \chy object. The two tasks are accomplished by:
<<eval = FALSE>>=
.is.hy (object)
validObject (object)
@
The first line checks whether \Robject{object} is a \chy object, the second checks its validity. 
Both functions return \Rcode{TRUE} if the checks succeed, otherwise they raise an error and stop.


\section{Loading the package}
\label{sec:loading-package}

To load \Rpackage{hyperSpec}, use
\nopagebreak
<<init>>=
library (hyperSpec)
@


\section{The structure of \Rclass{hyperSpec} objects}
\label{sec:structure-chy}

\Rclass{hyperSpec} is a S4 (or new-style) class. It has four so-called
\emph{slots} that contain parts of the object:
\begin{labeling}{@wavelength }
\item [{\Robject{@wavelength}}] containing a numeric vector with the wavelength
axis of the spectra.
\item [{\Robject{@data}}] a \Rclass{data.frame}with the spectra and all
further information belonging to the spectra
\item [{\Robject{@label}}] a list with appropriate labels (particularly
for axis annotations)
\item [{\Robject{@log}}] a \Rclass{data.frame} keeping track of what is
done with the object
\end{labeling}
However, it is good practice to use the functions provided by \Rpackage{hyperSpec}
to handle the objects rather than accessing the slots directly (tab~). This
also ensures that proper (\emph{valid}) objects are retained.

\begin{table}[tbh]
  \centering
  \begin{tabular}{>{\Robject}lll}
    \toprule
    \textbf{slot} & \textbf{get} & \textbf{set}\\
    \cmidrule(lr){1-1}    \cmidrule(lr){2-2}    \cmidrule(lr){3-3}
    @wavelength & \verb+wl+ & wl<- \\ 
    @data       & \verb+[+, \verb+[[+, \verb+$+, \verb+as.data.frame+, \verb+as.long.df+, \ldots & \verb+[<-+, \verb+[[<-+, \verb+$<-+\\ 
    @label & \verb+labels+ & \verb+labels<-+\\
    @log & \verb+logbook+ & \verb+logentry+\\
    \bottomrule
  \end{tabular}
  \caption{Get and set functions for the slots of \chy objects}
  \label{tab:getset}
\end{table}

Most of the data is stored in \Robject{@data}. This \Rclass{data.frame} has one special column, \Rcode{\$spc}. It is the column that actually contains the spectra. The spectra are stored in a matrix inside this column, as illustrated in figure~\ref{fig:structure}. Even if there are no spectra, \Rcode{\$spc} must still be present. It is then a matrix with zero columns.
\begin{figure}[bth]
\noindent \centering
\include{Strukturhyperspec}
\caption{\label{fig:structure}The structure of the data in a \Rpackage{hyperSpec} object.}
\end{figure}

Slot \Rcode{@label} contains an element for each of the columns in \Rcode{@data} plus one holding the label for the wavelength axis, \Rcode{.wavelength}. The elements of the list may be anything suitable for axis annotations, \ie they should be either character strings or expressions for ``pretty'' axis annotations (see figure~\ref{fig:example-plots} on page~\pageref{fig:example-plots}).  To get familiar with expressions for axis annotation, see \verb+? plotmath+ and \verb+demo (plotmath)+.

\section{Functions provided by \phy}
\label{sec:funct-prov-phy}

Table~\ref{tab:functions}~(p.~\pageref{tab:functions}) in the appendix gives an overview of the functions implemented by \phy. 

\section{Obtaining Basic Information about \Rpackage{hyperSpec} Objects}
As
\mFun{print, show, summary}
usual, the \Rmethod{print} and \Rmethod{show} methods display
information about the object, and \Rmethod{summary} yields some additional
details about the data handling done so far:

<<print>>=
chondro
summary (chondro)
@

The\mFun{nrow, ncol, nwl, dim}  data set \Robject{chondro} consists of \Sexpr{nrow (chondro)}
spectra with \Sexpr{nwl (chondro)} data points each, and \Sexpr{ncol (chondro)}
data columns: two for the spatial information plus \Robject{\$spc}.
These informations can be directly obtained by
<<nwl>>=
nrow (chondro)
nwl (chondro)
ncol (chondro)
dim (chondro)
@

The names of the columns in \Rcode{@data} are accessed by\mFun{colnames, rownames, dimnames, \emph{wl}} 
<<names>>=
colnames (chondro)
@

Likewise, \Rmethod{rownames} returns the names assigned to the spectra,
and \Rmethod{dimnames} yields a list of these three vectors (including
also the column names of \Robject{\$spc}). The column names of the spectra matrix are the wavelengths. They are accessed by \Rfunction{wl}, see section~\ref{sec:wavel-axis-conv}.

Extra\mFun{colnames<-, rownames<-} 
data column names and rownames of the object may be set by \Rfunction{colnames<-} and \Rfunction{rownames<-}, respectively. \Rfunction{colnames<-} renames the labels as well.

\section{Creating a \Rclass{hyperSpec} Object, Data Import and Export}
\label{sec:create}
\phy comes with filters for a variety of file formats. These are discussed in detail in a separate document. Use \verb+vignette ("file-io")+ to read about import and export of spectra into \chy objects.

\subsection{Creating a \Rclass{hyperSpec} Object from Spectra Matrix
and Wavelength Vector}

If the data is in R's workspace, a \Rclass{hyperSpec} object is
created by:\\
\Rcode{spc <- new (\textquotedbl{}hyperSpec\textquotedbl{}, spc =
  spectra.matrix, wavelength = wavelength.vector, data = extra.data)}\\
You will usually give the following arguments:
\begin{labeling}{\Rcode{wavelength}}
\item [{\Rcode{spc}}] the spectra matrix
\item [{\Rcode{wavelength}}] the wavelength axis vector
\item [{\Rcode{data}}] the extra data (possibly already including the spectra matrix in column   \texttt{spc})
\item [{\Rcode{label}}] a list with the proper labels. Do not forget the
wavelength axis label in \Rcode{\$.wavelength} and the spectral intensity
axis label in \Rcode{\$spc}.
\end{labeling}


\section{Combining and Decomposing \Rclass{hyperspec} Objects} 
\label{sec:combine}

\subsection{Binding Objects together}
\label{sec:bind}
\Rclass{hyperspec}
\mFun{\Rfunction{cbind} \Rfunction{rbind}}
Objects can be bound together, either by rows
to append a new spectral range or by columns to append new spectra

<<cbind>>=
dim (flu)
dim (cbind (flu, flu))
dim (rbind (flu, flu))
@
Thus, you can use \Rfunction{cbind} to add new spectral ranges, and \Rfunction{rbind} to add new spectra to your object.

There is also a more general function, \Rfunction{bind}, taking the
direction (\Rcode{\textquotedbl{}r\textquotedbl{}} or \Rcode{\textquotedbl{}c\textquotedbl{}})
as first argument and then all objects to bind either in separate
arguments or in a list.

As usual for \Rfunction{rbind} and \Rfunction{cbind}, the objects that should be bound together must have the same rows and columns, respectively.


\subsection{Binding Objects that do not share the same extra data and/or wavelength axis}
\label{sec:collapse}

\Rfunction{collapse} \mFun{\Rfunction{collapse}} combines objects that should be bound together by row, but they do not share the columns and/or spectral range.
The resulting object has all columns from all input objects, and all wavelengths from the input objects. If an input object does not have a particular column or wavelength, its value in the resulting object is \Rcode{NA}.

The \Robject{barbituates} data is a list of \Sexpr{length (barbituates)} \chy objects, each containing one mass spectrum. The spectra have \Sexpr{(min (sapply (barbituates, nwl)))} to 
\Sexpr{(max (sapply (barbituates, nwl)))} data points. 

<<collapse>>=
barb <- collapse (barbituates)
barb [[1:3, , min ~ min + 10i]]
@

\subsection{Matrix Multiplication}
\label{sec:matmult}

Two \chy objects can be matrix multiplied by \Rfunction{\%*\%}\mFun{\Rfunction{\%*\%}}. For an example, see the principal component analysis below (section~\ref{sec:pca} on page \pageref{sec:pca}).

\subsection{Decomposition}
\label{sec:decomposition}
Matrix decompositions are common operations during chemometric data analysis. The results, \eg of a principal component analysis are two matrices, the so-called scores and loadings. 
The results can have either the same number of rows as the spectra matrix they were calculated from (scores-like), or they have as many wavelengths as the spectra (loadings-like).

Both types of result objects can be ``re-imported'' into \chy objects with function \Rfunction{decomposition}\mFun{\Rfunction{decomposition}}. A scores-like object retains all per-spectrum information (\ie the extra data) while the spectra matrix and wavelength vector are replaced. 
A loadings-like object retains the wavelength information, while extra data is deleted (set to \Rcode{NA}) unless the value is constant for all spectra.

A demonstration can be found in the principal component analysis example (section~\ref{sec:pca}) on page \pageref{sec:pca}.

\section{Access to the data}
\label{sec:access-parts}
The main functions to retrieve the data of a \chy object are \Rfunction{[]}\mFun{\Rfunction{[]}, \Rfunction{[[]]}} and \Rfunction{[[]]}. 

The difference between these functions is that  \Rfunction{[]} returns a \chy object, whereas the result of \Rfunction{[[]]} is a data.frame if extra data columns were selected or otherwise the spectra matrix. Single extra data columns may be retrieved by \Rfunction{\$}\mFun{\Rfunction{\$}}.

In order to change data, use \Rfunction{[]<-}, \Rfunction{[[]]<-}, and \Rfunction{\$<-}\mFun{\Rfunction{[]<-}, \Rfunction{[[]]<-}, \Rfunction{\$<-}}.

\subsection{Selecting and Deleting Spectra}
\label{sec:select-delete-spectra}

The extraction function \Rfunction{[]} takes the spectra as first argument (For detailed help: see \verb+? `[`+). It may be a vector giving the indices of the spectra to extract (select), a vector with negative indices indicating which spectra should be deleted, or a logical. Note that a matrix given to  \Rfunction{[]} will be treated as a vector.

<<selspc, fig = TRUE>>=
plot (flu, col = "gray")
plot (flu [1 : 3], add = TRUE)
@ 

<<delspc, fig = TRUE>>=
plot (flu, col = "gray")
plot (flu [-3], add = TRUE)
@
<<selspc2, fig = TRUE>>=
plot (flu, col = "gray")
plot (flu [flu$c > 0.2], add = TRUE)
@

\subsection{Selecting Wavelength Ranges}
\label{sec:wavelength-axis}
Wavelength ranges can easily be selected using \Rfunction{[]}'s third argument:
<<fig = TRUE>>=
plot (paracetamol [,, 2800 ~ 3200])
@
 By default, the values given are treated as wavelengths, if they are indices into the columns of the spectra matrix, use \Rcode{wl.index = TRUE}:
<<fig = TRUE>>=
plot (paracetamol [,, 2800 : 3200, wl.index = TRUE])
@
Section~\ref{sec:wavelength-indices}~(p.~\pageref{sec:wavelength-indices}) details into the different possibilities of specifying wavelengths.

\subsection{Deleting Wavelength Ranges}
\label{sec:del-wavelengths}
Deleting wavelength ranges may be accomplished using negative index vectors together with \Rcode{wl.index = TRUE}. 
<<fig = TRUE>>=
plot (paracetamol [,, -(500 : 1000), wl.index = TRUE])
@
However, this mechanism works only if the proper indices are known. 

If the range to be cut out is rather known in the units of the wavelength axis, it is easier to select the remainder of the spectrum instead. To delete the spectral range from 1750 to 2800\,cm\textsuperscript{-1} of the paracetamol spectrum one can thus use:
<<fig = TRUE>>=
plot (paracetamol [,, c (min ~ 1750, 2800 ~ max)])
@
(It is possible to produce a plot of this data where the cut range is not bridged by a line and the wavelength axis is cut in order to save space. For details see the ``plotting'' vignette).

\subsubsection{Converting Wavelengths to Indices and vice versa}
\label{sec:wavelength-indices}
Spectra\mFun{\Rfunction{wl2i} \Rfunction{i2wl}}
in \Rpackage{hyperSpec} have always discretized wavelength
axes, they are stored in a matrix with column corresponding to one
wavelength. \Rpackage{hyperSpec} provides two conversion functions:
\Rfunction{i2wl} returns the wavelength corresponding to the given
indices and \Rfunction{wl2i} calculates index vectors from wavelengths.

If the wavelengths are given as a numeric vector, they are each converted
to the corresponding wavelength. In addition there is a more sophisticated
possibility of specifying wavelength ranges using a \emph{formula}.
The basic syntax is \emph{start~}$\sim$~\emph{end.} This yields
a vector \emph{index of start }\Rcode{:}\emph{ index of end.}

The result of the formula conversion differs from the numeric vector
conversion in three ways:
\begin{itemize}
\item The colon operator for constructing vectors accepts only integer numbers,
the tilde (for formulas) does not have this restriction.
\item If the vector does not take into account the spectral resolution,
one may get only every $n$\textsuperscript{th} point or repetitions of the same
index:\\
<<wl2ivec>>=
wl2i (flu, 405 : 410)
@
<<wl2ivec2>>=
wl2i (flu, 405 ~ 410)
@
<<wl2ivec3>>=
wl2i (chondro, 1000 : 1010)
@
<<wl2ivec4>>=
wl2i (chondro, 1000 ~ 1010)
@
\item If the object's wavelength axis is not ordered, the formula approach
will give weird results. In that (probably rare) case, use \Rfunction{orderwl} first
to obtain an object with ordered wavelength axis.
\end{itemize}
\emph{start} and \emph{end} may contain the special variables \Robject{min}
and \Robject{max} that correspond to the lowest and highest wavelengths
of the object:

<<wl2i.minmax>>=
wl2i (flu, min ~ 410)
@

Often, specifications like \emph{wavelength \textpm $n$ data points}
are needed. They can be given using complex numbers in the formula.
The imaginary part is added to the index calculated from the wavelength
in the real part:

<<wl2i.im>>=
wl2i (flu, 450 - 2i ~ 450 + 2i)
wl2i (flu, max - 2i ~ max)
@

To specify several wavelength ranges, use a list containing the formulas
and vectors\footnote{Formulas are combined to a list by \Rfunction{c}.}:

<<wl2i.list>>=
wl2i (flu, 450 - 2i ~ 450 + 2i)
wl2i (flu, c (min ~ 406.5, max - 2i ~ max))
@

This mechanism also works for the wavelength arguments of \Rfunction{[]},
\Rfunction{[[]]}, and \Rfunction{plotspc}.

\subsubsection{Changing the Wavelength Axis}
\label{sec:wavel-axis-conv}

Sometimes wavelength axes need to be transformed, \eg converting from wavelengths to frequencies. In this case, retrieve the wavelength axis vector with \Rfunction{wl}\mFun{\Rfunction{wl}, \Rfunction{wl<-}}, convert each value of the resulting vector and assign the result with \Rfunction{wl<-}. Also the label of the wavelength axis may need to be adjusted.

As an example, convert the wavelength axis of \Robject{laser} to frequencies. As the wavelengths are in nanometers, and the frequencies are easiest expressed in terahertz, an additional conversion factor of 1000 is needed:
<<>>=
laser
wavelengths <- wl (laser)
frequencies <- 2.998e8 / wavelengths / 1000
wl (laser) <- frequencies
labels (laser, ".wavelength") <- "f / THz"
laser
rm (laser)
@

There are other possibilities of invoking \Rfunction{wl<-} including the new label, \eg
<<>>=
wl (laser, "f / THz") <- frequencies
@
and
<<>>=
wl (laser) <- list (wl = frequencies, label = "f / THz")
@
see \verb+?`wl<-`+ for more information.


\subsection{Selecting Extra Data Columns }
\label{sec:accessing-extra-data}
The second argument of the extraction functions \Rfunction{[]} specifies the (extra) data columns. They can be given like any column specification for a \Rclass{data.frame}, \ie numeric, logical, or by a vector of the column names:

<<>>=
chondro [1 : 3, 1]
@

 
They can be given like any column specification for a \Rclass{data.frame},
\ie numeric, logical, or by a vector of the column names:

<<data>>=
colnames (chondro)
chondro [[1 : 3, 1]]
chondro [[1 : 3, -3]]
chondro [[1 : 3, "x"]]
chondro [[1 : 3, c (TRUE, FALSE, FALSE)]]
@

To select one column, the \Rcode{\$} operator is more convenient:

<<data2>>=
flu$c
@

The extra data may also be set this way:
<<data3>>=
flu$n <- list (1 : 6, label = "sample no.")
@
This function will append new columns, if necessary.

\subsection{Accessing the Spectra Matrix}
\label{sec:access-spectra-matr}
If the spectra matrix (or the data.frame including the extra data) is needed, use \Rfunction{[[]]}\mFun{\Rfunction{[[]]}}.
It accepts the same arguments as \Rfunction{[]}. 

if the spectra \Rclass{matrix} or the \Rclass{data.frame} is needed rather than a \Rclass{hyperSpec} object)

\subsection{More on the Square-Bracket Operators for Getting and Replacing Values}
\label{sec:square-brack-replace}

\

\Rfunction{[[]]} also accepts index matrices of size $n \times 2$.
<<data2>>=
indexmatrix <- matrix (c (1 : 3, 1 : 3), ncol = 2)
indexmatrix
chondro [[indexmatrix, wl.index = TRUE]]
diag (chondro [[1 : 3, , min ~ min + 2i]])
@



\subsection{Fast Access to Parts of the \Rclass{hyperSpec} Object}
\label{sec:fast-access-parts}
\mFun{\Rfunction{[[]] \$. \$..}}

\Rclass{hyperSpec} comes with three abbreviation functions for easy
access to the data:
\begin{description}
\item [\Robject{x} \Rfunction{[[]]}] returns the spectra matrix (\Rcode{x\$spc}).
\item [\Robject{x} \Rfunction{[[\Rfunarg{i}, , \Rfunarg{l}]]}] the cut spectra matrix is returned if wavelengths are specified in \Rfunarg{l}.
\item [\Robject{x} \Rfunction{[[\Rfunarg{i}, \Rfunarg{j}, \Rfunarg{l}]]}] If data columns are selected (second index), the result is a \Rclass{data.frame}.
\item [\Robject{x} \Rfunction{[[\Rfunarg{i}, , \Rfunarg{l}]] <-}] Also, parts of the spectra matrix can be set (only indices for spectra and wavelength are allowed for this function).
\item [\Robject{x} \Rfunction{[\Rfunarg{i}, \Rfunarg{j}] <-}] sets parts of \Rcode{x@data}.
\item [\Robject{x} \Rfunction{\$.}] returns the complete \Rclass{data.frame} \Rcode{x@data}, with the spectra in column \Rcode{\$spc}.
\item [\Robject{x} \Rfunction{\$..}] returns the extra data (\Rcode{x@data} without \Rcode{x\$spc}).
\item [\Robject{x} \Rfunction{\$.. <-}] sets the extra data (\Rcode{x@data} without \Rcode{x\$spc}). However, the columns must match exactly in this case.
\end{description}


\section{Plotting}
\phy offers a variety of possibilities to plot spectra, spectral maps, the spectra matrix, time series, depth profiles, etc..
This all is discussed in a separate document: see \verb+vignette ("plotting")+.

\section{Spectral (Pre)processing}
\subsection{Cutting the Spectral Range}\mFun{\Rfunction{[]} \Rfunction{[[]]}}
The extraction functions \Rfunction{[]} and \Rfunction{[[]]}
can be used to cut the spectra: Their third argument takes wavelength
specifications as discussed above and also logicals (i.e. vectors
specifying with \Rcode{TRUE}/\Rcode{FALSE} for each column of \Rcode{\$spc}
whether it should be included or not.\\
\Rfunction{[]} returns a \Rclass{hyperSpec} object, \Rfunction{[[]]}
the spectra \Rclass{matrix}\Rcode{\$spc} (or the \Rclass{data.frame}\Rcode{@data}
if data columns were specified, too) only.

<<cut.wl>>=
flu [,, min ~ 408.5]
flu [[,, c (min ~ min + 2i, max - 2i ~ max)]]
@


\subsection{Spectral Interpolation and Smoothing} \mFun{\Rfunction{spc.bin} \Rfunction{spc.loess}}
Frequently, a \Rclass{hyperSpec} object needs to be interpolated
onto a new wavelength axis. e.\,g. because measurements resulted
in slightly shifted wavelength axes. Or data from a grating spectrometer
with unequal data point spacing should be interpolated onto an evenly
spaced wavelength axis. Also, the spectra can be smoothed: reducing
the spectral resolution allows to increase the signal to noise ratio.
For chemometric data analysis reducing the number of data points per
spectrum may be crucial as it reduces the dimensionality of the data.

\Rpackage{hyperSpec} provides two functions to change the wavelength
axis of \Rclass{hyperSpec} objects: \Rfunction{spc.bin} and \Rfunction{spc.loess}.

\Rfunction{spc.bin} bins the spectral axis by averaging every \Rfunarg{by}
data points.

<<fig-loess, fig = TRUE, width = 10, height = 5, include = FALSE>>=
plot (paracetamol, wl.range = c (300 ~ 1800, 2800 ~ max), xoffset = 850)
p <- spc.loess (paracetamol, c(seq (300, 1800, 2), seq (2850, 3150, 2)))
plot (p, wl.range = c (300 ~ 1800, 2800 ~ max), xoffset = 850, col = "red", add = TRUE)
@
<<fig-loess-kl, fig = TRUE, width = 5, height = 5, include = FALSE, echo = FALSE>>=
plot (paracetamol [, , 1600 ~ 1670])
plot (p [, , 1600 ~ 1670], col = "red", add = TRUE)
@

%
\begin{figure}
\includegraphics[width=0.66\textwidth]{fig/fig-fig-loess}
\includegraphics[width=0.33\textwidth]{fig/fig-fig-loess-kl}


\captionbelow{\label{fig-spcloess}Smoothing interpolation by \Rfunction{spc.loess}
with new data point spacing of 2 cm\textsuperscript{-1}. The magnification
on the right shows how interpolation may cause a loss in signal.}
\end{figure}


\Rfunction{spc.loess} applies R's \Rfunction{loess} function for
spectral interpolation. Figure \ref{fig-spcloess} shows the result
of interpolating from 300 to 1800 and 2850 to 3150 cm\textsuperscript{-1}
with 2 cm\textsuperscript{-1} data point distance. This corresponds
to a spectral resolution of about 4 cm\textsuperscript{-1}, and the
decrease in spectral resolution can be seen at the sharp bands where
the maxima are not reached (due to the fact that the interpolation
wavelength axis does not necessarily hit the maxima. The original
spectrum had \Sexpr{nwl (paracetamol)} data points with unequal data
point spacing (between \Sexpr{signif (min (diff (wl (paracetamol))), 2)}
and \Sexpr{signif (max (diff (wl (paracetamol))), 2)} cm\textsuperscript{-1}).
The interpolated spectrum has \Sexpr{nwl (p)} data points.


\subsection{Background Correction}

To subtract a background spectrum of each of the spectra in an object,
use \Rcode{sweep (spectra, 2, background.spectrum, \textquotedbl{}-\textquotedbl{})}.


\subsection{Offset Correction}

Calculate the offsets and sweep them off the spectra:

<<ofs>>=
offsets <- apply (chondro, 1, min)
chondro.offset.corrected <- sweep (chondro, 1, offsets, "-")
@


\subsection{Baseline Correction}

\Rpackage{hyperSpec} comes with two functions to fit polynomial baselines.

\Rfunction{spc.fit.poly} fits a polynomial baseline of the given
order. A least-squares fit is done so that the function may be used
on rather noisy spectra. However, the user must supply an object that
is cut appropriately. Particularly, the supplied wavelength ranges
are not weighted.

\Rfunction{spc.fit.poly.below} tries to find appropriate support
points for the baseline iteratively.

Both functions return a \Rclass{hyperSpec} object containing the
fitted baselines. They need to be subtracted afterwards:

<<bl>>=
bl <- spc.fit.poly.below (chondro)
chondro <- chondro - bl
@

For details, see \Rcode{vignette (baselinebelow)}.


\subsection{Intensity Calibration}


\subsubsection{Correcting by a constant, e.\,g. Readout Bias}

CCD cameras often operate with a bias, causing a constant value for
each pixel. Such a constant can be immediately subtracted:\\
\Rcode{spectra - constant}


\subsubsection{Correcting Wavelength Dependence}

This means that for each of the wavelengths the same correction needs
to be applied to all spectra.
\begin{enumerate}
\item There might be wavelength dependent offsets (background or dark spectra).
They are subtracted:\\
\Rcode{sweep (spectra, 2, offset.spectrum, \textquotedbl{}-\textquotedbl{})}
\item A multiplicative dependency such as a CCD's photon efficiency: \\
\Rcode{sweep (spectra, 2, photon.efficiency, \textquotedbl{}/\textquotedbl{})}
\end{enumerate}

\subsubsection{Spectra Dependent Correction}

If the correction depends on the spectra (e.\,g. due to inhomogeneous
illumination while collecting imaging data%
\footnote{imaging (as opposed to mapping) refers to simultaneously collecting
spatially resolved spectra, either 2d images or line imaging.%
}), the \Rfunarg{MARGIN}of the \Rfunction{sweep} function needs to
be 1:
\begin{enumerate}
\item Pixel dependent offsets are subtracted:\\
\Rcode{sweep (spectra, 2, pixel.offsets, \textquotedbl{}-\textquotedbl{})}
\item A multiplicative dependency: \\
\Rcode{sweep (spectra, 2, illumination.factors, \textquotedbl{}{*}\textquotedbl{})}
\end{enumerate}

\subsection{Normalization}
\begin{enumerate}
\item Calculate appropriate normalization factors:\\
\Rcode{factors <- 1 / apply (spectra, 1, sum)} for area normalization.
\Rfunction{mean} gives equal results, just that the Intensities are
on the same scale as before.\\
For minimum-maximum-normalization, first do an offset- or baseline
correction, then calculate the \emph{\Rcode{factors}} using \Rfunction{max}.\\
You may calculate the factors using only a certain wavelength range,
thereby normalizing on a particular band or peak.
\item Again, sweep the factor off the spectra:\\
\Rcode{normalized <- sweep (spectra, 1, factors, \textquotedbl{}{*}\textquotedbl{})}
\end{enumerate}
<<norm>>=
factors <- 1 / apply (chondro, 1, mean)
chondro <- sweep (chondro, 1, factors, "*")
@


\subsection{Centering the Data}

Centering means that the mean spectrum is subtracted from each of
the spectra. Many data analysis techniques, like principal component
analysis, partial least squares, etc., work much better on centered
data.

However, from a spectroscopic point of view it depends on the particular
data set whether centering does make sense or not.

It is perfectly fine to centre the \Robject{flu} data set: the interpretation
is that centering the data cancels the offset (background spectrum
etc.) of the calibration:

<<centre-flu>>=
flu.centered <- sweep (flu, 2, apply (flu, 2, mean), "-")
@

<<fig-centre-flu, fig = TRUE, width = 10, height = 5, include = FALSE>>=
plot (flu.centered)
@

On the other hand, the \Robject{chondro} data set consists of Raman
spectra, so the spectroscopic interpretation of centering is getting
rid of the the average chemical composition of the sample. But: what
is the meaning of the {}``average spectrum'' of an inhomogeneous
sample? In this case it is better to subtract the minimum
spectrum (which will hopefully have almost the same benefit on the
data analysis) as it is the spectrum of that chemical composition
that is underlying the whole sample.

One more point to consider is that the actual minimum spectrum will
pick up lots of the negative noise. In order to avoid that, using
e.~g. the 5\textsuperscript{th} percentile spectrum is more suitable:

<<perc>>=
chondro <- sweep (chondro, 2, apply (chondro, 2, quantile, 0.05), "-")
@
<<fig-centre-ch, fig = TRUE, width = 10, height = 5, include = FALSE>>=
plot (chondro, "spcprctl5")
@


\subsection{Variance Scaling}

Variance scaling is often used in multivariate analysis to adjust
the influence and scaling of the variates (that are typically different
physical values). However, it is hardly appropriate for spectra that
do have the same scale of the same physical value.


\subsection{Multiplicative Scatter Correction (MSC)}

MSC can be done using \Rfunction{msc} from package \Rpackage{pls}\citep{Wehrens2007}.
It operates on the spectra matrix:

<<msc, eval = FALSE>>=
library (pls)
chondro.msc <- chondro
chondro.msc [[]] <- msc (chondro [[]])
@


\subsection{Spectral Arithmetic} \mFun{\Rfunction{+ - {*} / \textasciicircum{} log log10}}

Basic mathematical functions are defined for \Rclass{hyperSpec} objects.
You may convert spectra:\\
\Rcode{absorbance.spectra = - log10 (transmission.spectra)}

In this case, do not forget to adapt the label:\mFun{\Rfunction{labels}}
<<label, eval = FALSE>>=
labels (absorbance.spectra)$spc <- "A"
@

Be careful: R's \Rfunction{log} function calculates the natural
logarithm if no base is given.

The basic arithmetic operators work element-wise in R. Thus they
all need either a scalar, or a matrix (or \Rclass{hyperSpec} object)
of the correct size.

Matrix multiplication is done by \Rfunction{\%{*}\%} \mFun{\Rfunction{\%{*}\%}},
again each of the operands may be a matrix or a \Rclass{hyperSpec} object, and must have the correct dimensions.


\section{Data Analysis }
\subsection{Data Analysis Methods using a data.frame \\
e.\,g. Principal Component Analysis with \Rfunction{prcomp}}
\label{sec:pca}
The \Rcode{\$.} notation is handy, if a data analysis function expects
a \Rclass{data.frame}. The column names can then be used in the formula:

<<pca>>=
pca <- prcomp (~ spc, data = chondro$., center = FALSE)
@

Results of such a decomposition can be put again into \Rclass{hyperSpec}
objects. This allows to plot \eg the loading like spectra, or score
maps, see figure~\ref{fig:pca}.

<<decomp>>=
scores <- decomposition (chondro, pca$x, label.wavelength = "PC", 
                         label.spc = "score / a.u.")
scores
@ 

The loadings can be similarly re-imported:
<<loadings>>=
loadings <- decomposition (chondro, t(pca$rotation), scores = FALSE, 
                           label.spc = "loading I / a.u.")
loadings
@
There is, however, one important difference. The loadings are thought of as values computed from all spectra togehter. Thus no meaningful extra data can be assigned for the loadings object (at least not if the column consists of different values). Therefore, the loadings object lost all extra data (see above). 

\Rfunarg{retain.columns} triggers whether columns that contain different values should be dropped. If it is set to \Rcode{TRUE}, the columns are retained, but contain \Rcode{NA}s:
<<retain.col>>=
loadings <- decomposition (chondro, t(pca$rotation), scores = FALSE, 
                           retain.columns = TRUE, label.spc = "loading I / a.u.")
loadings[1]$..
@
If an extra data column does contain only one unique value, it is retained anyways:
<<retain>>=
chondro$measurement <- 1
loadings <- decomposition (chondro, t(pca$rotation), scores = FALSE, 
                           label.spc = "loading I / a.u.")
loadings[1]$..
@
\begin{figure}
\setkeys{Gin}{width = .495\textwidth}
\subfloat[\label{fig-pca-load}]{
<<pca-load, fig = TRUE, width = 8, height = 5, echo = FALSE>>=
plot (loadings [1:3], stacked = TRUE)
@
}
\subfloat[\label{fig-pca-score}]{
<<pca-score, fig = TRUE, width = 8, height = 5, echo = FALSE>>=
plotmap (scores [,,2], col.regions = div.palette (20))
@
}
\caption{\label{fig:pca}
  \subref{fig-pca-load} The first three loadings: \Rcode{plot (loadings [1 : 3], stacked = TRUE)}.  
  \subref{fig-pca-score} The second score map: \Rcode{plotmap (scores [, , 2])}}.
\end{figure}

\subsubsection{PCA as Noise Filter}
\label{sec:pca-as-noise}
Principal component analysis is sometimes used as a noise filtering technique. The idea is that the relevant differences are captured in the first components while the higher components contain noise only. Thus the spectra are reconstructed using only the first $p$ components.

This reconstruction is in fact a matrix multiplication:
\[ spectra^{(nrow \times nwl)} = scores^{(nrow \times p)} loadings^{(p \times nwl)} \]
Note that this corresponds to a model based on the Beer-Lambert law:
\[ A_n (\lambda) = c_{n,i} \epsilon (i, \lambda) + error \]
The matrix formulation puts the $n$ spectra into the rows of $A$ and $c$, while the $i$ pure components appear in the columns of $c$ and rows of the absorbance coefficients $\epsilon$.

For an ideal data set (constituents varying independently, sufficient signal to noise ratio) one would expect the principal component analysis to extract something like the concentrations and pure component spectra.

If we decide that only the first 10 components actually carry spectroscopic information, we can reconstruct spectra with better signal to noise ratio:
<<pca-smooth>>=
smoothed <- scores [,, 1:10] %*% loadings [1:10]
@
Keep in mind, though, that we cannot be sure how much \emph{useful} information was discarded with the higher components. This kind of noise reduction may influence further modeling of the data. Mathematically speaking, the rank of the 
\Sexpr{nrow (chondro)} $\times$ \Sexpr{nwl (chondro)} spectra matrix was reduced to 10.

\subsection{Data Analysis Methods using a matrix \\
e.\,g. Hierarchical Cluster Analysis\label{HCA}}

<<hca>>=
dist <- pearson.dist (chondro [[]])
dendrogram <- hclust (dist, method = "ward")
@
<<dend, fig = TRUE, width = 5, height = 5, include = FALSE>>=
plot (dendrogram)
@

In order to plot a cluster map, the cluster membership needs to be
calculated from the dendrogram.

First, cut the dendrogam so that three clusters result:

<<dendcut>>=
chondro$clusters <- as.factor (cutree (dendrogram, k = 3))
@
As the cluster membership was stored as factor, the levels can be meaningful names, which are displayed in the color legend.
<<clustname>>=
levels (chondro$clusters) <- c ("matrix", "lacuna", "cell")
@
Then the result may be plotted (figure~\ref{fig:clust:map}):
<<clustmap, fig = TRUE, width = 7.5, height = 5, include = FALSE, echo = FALSE>>=
cluster.cols <- c ("dark blue", "orange", "#C02020")
plotmap (chondro, clusters ~ x * y, col.regions = cluster.cols)
@

%
\begin{figure}
\subfloat[\label{fig:clust:dend}]{\includegraphics[width=0.33\textwidth]{fig/fig-dend}}
\subfloat[\label{fig:clust:map}]{\includegraphics[width=0.33\textwidth]{fig/fig-clustmap}}
\subfloat[\label{fig:clust:spc}]{\includegraphics[width=0.33\textwidth]{fig/fig-clustmean}}
\caption{The results of the cluster analysis: \subref{fig:clust:dend} the
dendrogram \subref{fig:clust:map} the map of the 3 clusters \subref{fig:clust:spc}
the mean spectra.}
\end{figure}

\subsection{Calculating group-wise Sum Characteristics \\
e.\,g. Cluster Mean Spectra}

\Rfunction{aggregate} applies the function given in \Rfunarg{FUN}
to each of the groups of spectra specified in \Rfunarg{by}. \mFun{\Rfunction{aggregate}}

So we may plot the cluster mean spectra:

<<clustmean, fig = TRUE, width = 7.5, height = 5, include = FALSE>>=
means <- aggregate (chondro, by = chondro$clusters, mean_pm_sd)
plot (means, col = cluster.cols, stacked = ".aggregate", fill = ".aggregate")
@


\subsection{Splitting an Object}

A \Rclass{hyperSpec} object may also be split into a list of \Rclass{hyperSpec}
objects:

<<split>>=
clusters <- split (chondro, chondro$clusters)
clusters
@

Splitting can be reversed by \Rfunction{rbind} (see section~\ref{sec:bind}, page~\pageref{sec:bind}).

\bibliographystyle{unsrtnat}
\bibliography{introduction}

\appendix
\section{Overview of the functions provided by \phy}
\label{tab:functions}

\begin{small}
\renewcommand{\arraystretch}{1.5}
\begin{longtable}{>{\raggedright}p{0.3\textwidth}p{0.65\textwidth}}
\toprule
\textbf{Function} & \textbf{Explanation}\\
\cmidrule(lr){1-1}\cmidrule(lr){2-2}
\endhead
<<tab-fn, results = tex, echo = FALSE>>=
make.fn.table <- function (){
load ("functions.RData")
functions <- subset (functions, !internal)
functions$group <- functions$group[,drop=TRUE]

TeX.escape <- function (x){
#  x <- gsub ("^\\\\([^\\\\])", "\\\\\\\\\\1", x)
#  x <- gsub ("[^\\\\]\\\\$", "\\1\\\\\\\\", x)
  x <- gsub ("([^\\\\]|^)\\$", "\\1\\\\$", x)
  x <- gsub ("([^\\\\]|^)_", "\\1\\\\_", x)
  x <- gsub ("([^\\\\]|^)%", "\\1\\\\%", x)
  x
}

for (g in levels (functions$group)){
  cat ("\\multicolumn{2}{l}{\\emph{",g, "}}\\\\\n", sep = "")
  df <- t (functions [functions$group == g, c ("name", "description")])
  cat (paste (paste ("\\verb+", df[1,], "+", sep = ""), df[2,], sep = " & ", collapse ="\\\\\n"),"\\\\\n")
}
}
make.fn.table()
@
\bottomrule
\end{longtable}
\end{small}

<<cleanup, echo = FALSE, results = hide>>=
rm (list = ls () )
@
\end{document}
