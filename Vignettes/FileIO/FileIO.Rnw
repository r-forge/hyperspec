% -*- mode: noweb; noweb-default-code-mode: R-mode; -*- 
\documentclass[english, a4paper, 10pt, headings=small, DIV11]{scrartcl}
\usepackage{makeidx}
\makeindex

\SweaveInput{vignettes.defs}
\hypersetup{pdftitle={FileIO}, 
 pdfauthor={C. Beleites},
 pdfsubject={Vignette File Import and Export for R package hyperSpec},
 pdfkeywords={hyperSpec, data format, file, import, export}}

% \VignetteIndexEntry{FileIO: Import and Export of Spectra into R/hyperSpec}
% \VignetteKeywords{hyperSpec, import, export, .spc, ENVI, ASCII}
% \VignettePackage{hyperSpec}

<<echo = FALSE, results = hide>>=
library (e1071)
make.all.permutations <- function (...){
  x <- c (...)
  x <- matrix (x [permutations (length (x))], ncol = length (x))
  x <- apply (x, 1,  paste, collapse = "!")
  cat (paste ("\\index{", x, "}\n", sep = ""), sep = "")
}
@
\begin{document}
\title{Import and Export of Spectra Files\\
Vignette for the R package \Rpackage{hyperSpec} }
\maketitle

\warnbox{Supported File Formats}{
  \phy supports a number of file formats relevant for different types of spectroscopy. This is
naturally only a subset of the file formats produced by different spectroscopic equipment. 

\indent If you use \phy with data formats not mentioned in this document, please send an email to \mailme, so that this document can be updated. 

The information should include
\begin{itemize}
\item The type of spectroscopy
\item Spectrometer model, manufacturer, and software
\item The ``native'' file format (including a sample file)
\item Description of relevant procedures to convert the file
\item R code to import the data together with an example file that can actually be read by R.
\item Documentation, particularly the description of the data format
\end{itemize}

If you need help finding out how to import your data, \phy has a mailing
list \href{mailto:hyperspec-help@lists.r-forge.r-project.org}{\nolinkurl{hyperspec-help@lists.r-forge.r-project.org}}, subscription and archives are available at \url{http://r-forge.r-project.org/mail/?group_id=366}.
}\\[1cm]
\warnbox{Reproducing the Examples in this Vignette}{
The source code of this vignette including the spectra files are available as .zip file at \phy's
home page:
 \url{http://hyperspec.r-forge.r-project.org/FileIO.zip}
 
 Note that some definitions are in file \texttt{vignettes.defs}.
}
\clearpage
\tableofcontents

\section{Introduction}
This document describes how spectra can be imported into \chy objects. Some possibilities to export
\chy objects as files are mentioned, too.

The most basic funtion to create \chy objects is \Rfunction{new ("hyperSpec")}
(section~\ref{sec:new}). It makes a \chy object from data already in R's workspace. Thus, once the
spectra are imported into R, conversion to \chy objects is straightforward.

In addition, \phy comes with predifined import functions for different data formats.
This document divides the discussion into dealing with ASCII files (section~\ref{sec:ascii}, p.~\pageref{sec:ascii}) and binary file formats (section~\ref{sec:binary-file-formats}, p.~\pageref{sec:binary-file-formats}).
If data export for the respective format is possible, it is discussed in the same sections.
As sometimes the actual data written by the spectrometer software exhibits peculiarities, \phy offers
several specialized import functions. These are in general named after the data format followed by the
manufacturer (\eg read.ENVI.Nicolet).

Overview lists of the directly supported file formats are in the appendix: sorted by file format
(appendix~\ref{sec:format}, p.~\pageref{sec:format}), manufacturer (appendix~\ref{sec:manufacturer}, p.~\pageref{sec:manufacturer}),  and by spectroscopy (appendix~\ref{sec:spectroscopy}, p.~\pageref{sec:spectroscopy}).

\section{Creating a \chy object with \Rfunction{new}}
\label{sec:new}
\index{new!hyperSpec object}
\index{initialize!hyperSpec object}
\index{create!hyperSpec object}
\index{hyperSpec object!create}
To create a \Rclass{hyperSpec} object from data in R's workspace, use:
\begin{Schunk}
  \begin{Sinput}
spc <- new ("hyperSpec", spc, wavelength, data, label)}
\end{Sinput}
\end{Schunk}
With the arguments:
\begin{labeling}{\Rcode{wavelength}}
\item [\Rcode{spc}] the spectra matrix (may also be given as matrix inside column \Rcode{\$spc} of \Rcode{data})
\item [\Rcode{wavelength}] the wavelength axis vector
\item [\Rcode{data}] the extra data (possibly already including the spectra matrix in column  
\texttt{spc})
\item [\Rcode{label}] a list with the proper labels. Do not forget the
wavelength axis label in \Rcode{\$.wavelength} and the spectral intensity
axis label in \Rcode{\$spc}.
\end{labeling}

Thus, once your data is in R's workspace, creating a \chy object is easy. I suggest wrapping the code
to import your data and the line joining it into a \chy object by your own import function. You are
more than welcome to contribute such import code to \phy. Secion~\ref{sec:writing-Import}, (p.~\pageref{sec:writing-Import}) discusses examples of custom import functions.

\section{ASCII files}
\label{sec:ascii}
\label{sec:read.txt.long}
\label{sec:read.txt.wide}
\index{ASCII!long|see{ASCII long}}
\index{ASCII!wide|see{ASCII wide}}
Currently, \Rclass{hyperSpec} provides two functions for general ASCII data import:
\begin{labeling}{\Rfunction{write.txt.wide}}
\item [\Rfunction{read.txt.long}] imports long format ASCII files, \ie one intensity value per row
\item [\Rfunction{read.txt.wide}] imports wide format ASCII files, \ie one spectrum per row
\end{labeling}

The import functions immediately return a \Rclass{hyperSpec} object.

Internally, they use \Rfunction{read.table}, a very powerful ASCII import function.
R supplies another ASCII import function, \Rfunction{scan}.  \Rfunction{scan} imports numeric data
matrices and is faster than \Rfunction{read.table}, but cannot import column names. 
If your data does not contain a header or it is not important and can safely be skipped, you may want
to import your data using \Rfunction{scan}.

\subsection{ASCII files with samples in columns}
\label{sec:ascii-files-cols}

<<echo = FALSE, results = tex>>=
make.all.permutations ("Bruker", "powder diffraction")
make.all.permutations ("Bruker", "x-ray")
@
\index{Bruker!AXS}
\index{ASCII!transposed}
\index{ASCII!samples in columns}
Richard Pena asked about importing another ASCII file type:
\begin{quote}
\emph{\noindent Triazine5\_31.txt file corresponds to X ray powder diffraction data (Bruker AXS). The
native files data ``.raw'' are read with EVA software then they are converted into .uxd file with the
File Exchange software (Bruker AXS). The  .uxd file are opened with Excel software and saved as .txt
file, csv file (ChemoSpec) or xls.\\
The first and following columns corresponds to the angle diffraction and the intensity values of
samples respectively.}
\end{quote}

This file thus differs from the ASCII formats discussed above in that the samples are actually in
columns whereas \chy expects them to be in rows. The header line gives the name of the sample.
Import is straightforward, just the spectra matrix needs to be transposed to make a \chy object:
<<read.txt.t>>=
file <- read.table ("txt.t/Triazine 5_31.txt", header = TRUE, dec = ",", sep = "\t")

triazine <- new ("hyperSpec", wavelength = file [,1], spc = t (file [, -1]),
                 data = data.frame (sample = colnames (file [, -1])),
                 label = list (.wavelength = expression (2 * theta / degree), 
                               spc = "I / a.u."))
triazine
@
<<plot-triazine, fig = TRUE>>=
plot (triazine)
@

\subsection{JCAMP-DX}
\label{sec:jcamp-dx}
<<echo = FALSE, results = tex>>=
make.all.permutations ("ASCII", "JCAMP-DX")
@
\index{jdx|see{JCAMP-DX}}
JCAMP-DX files\cite{McDonald1988} are not supported as there has not yet been the need to import them. 

\subsection{ASCII Export} 
ASCII export can be done in wide and long format using \Rfunction{write.txt.long} and
\Rfunction{write.txt.wide}. If you need a specific header or footer, use R's functions for writing
files: \Rfunction{write.table}, \Rfunction{write}, \Rfunction{cat} and so on offer fine-grained
control of writing ASCII files.

\section{Binary file formats}
\label{sec:binary-file-formats}

\subsection{Matlab Files}
\label{sec:readMat}
\index{Matlab}
Matlab files can be read and written using the package \Rpackage{R.matlab}\citep{R.matlab},
which is available at CRAN and can be installed by \Rcode{install.packages (\textquotedbl
R.matlab\textquotedbl)}.
\begin{Schunk}
  \begin{Sinput}
spc.mat <- readMat ("spectra.mat")
\end{Sinput}
\end{Schunk}

If the .mat file was saved with compression, the additional package \Rpackage{Rcompression} is
needed. It can be installed from omegahat: 
\begin{Schunk}
  \begin{Sinput}
install.packages("Rcompression", repos = "http://www.omegahat.org/R")
\end{Sinput}
\end{Schunk}
See the documentation of \Rpackage{R.matlab} for more details and possibly needed further packages.

\Rfunction{readMat} imports the .mat file's contents as a list. The variables in the .mat file are
properly named elements of the list. The \chy object can be created using \Rfunction{new},
see~\ref{sec:new}~(p.~\pageref{sec:new}).

Again, you probably want to wrap the import of your matlab files into a function.

\subsubsection{Matlab Export}
\label{sec:writing-matlab-files}
\Rpackage{R.matlab}'s function \Rfunction{writeMat} can be used to write R objects into .mat files.
To save an \chy object \Robject{x} for use in Matlab, you most likely want to save:
\begin{itemize}
\item the wavelength axis as obtained by \Rcode{wl (x)},
\item the spectra matrix as obtained by \Rcode{x [[]]}, and
\item possibly also the extra data as obtained by \Rcode{x\$..}
\item as well as the axis labels \Rcode{labels (x)}.
\item Alternatively, \Rcode{x\$.} yields the extra data together with the spectra matrix.
\end{itemize}
However, it may be convenient to transform the saved data according to how it is needed in Matlab.
The functions \Rfunction{as.long.df} and \Rfunction{as.wide.df} may prove useful for reshaping the
data.

\subsection{ENVI Files}
\label{sec:read.ENVI}

<<echo = FALSE, results = tex>>=

make.all.permutations ("ENVI", "Map", "Infrared")
make.all.permutations ("ENVI", "Infrared", "Bruker")

@
\index{FT-IR|see{Infrared}}
\index{Image|see{Map}}
 ENVI files are binary data accompanied by an ASCII header file. \phy's function
\Rfunction{read.ENVI} can be used to import them.

As we experienced missing header files (Bruker's Opus software frequently produced header files
without any content), the data that would usually be read from the header file can also be handed to
\Rfunction{read.ENVI} as a list. The help page gives details on what elements the list should
contain, see also the discussion of ENVI files written by Bruker's OPUS software (section~\ref{sec:read.ENVI.Bruker}, p.~\pageref{sec:read.ENVI.Bruker}).

Here is a demonstration of the use of \Rfunction{read.ENVI}:
<<read.ENVI>>=
spc <- read.ENVI ("ENVI/example2.img")
spc
@


\subsubsection{ENVI Export}
\label{sec:envi-export}
Use package \Rpackage{caTools} or \Rpackage{rgdal} with GDAL for writing ENVI files.

\subsection{spc Files}
\label{sec:read.spc}

<<echo = FALSE, results = tex>>=
make.all.permutations ("spc", "Kaiser", "Raman")
make.all.permutations ("spc", "Renishaw", "Raman")
@
\index{spc}

Thermo Galactic's .spc file format\cite{Galactic1997} can be imported by \Rfunction{read.spc}. 

A variety of sub-formats exists. \phy's import\Rfunction{read.spc} function does \emph{not} support the old file format that was used before 1996. In addition, no test data with \emph{w planes} was available
--- thus the import of such files could not be tested. If you come across such files, please contact
the package maintainer (\mailme).

Here are some tests using Thermo Galactic's example files:
<<read.spc>>=
## old format files stop with an error:
old <- paste ("spc", c ('CONTOUR.SPC', 'DEMO 3D.SPC', 'LC DIODE ARRAY.SPC'), sep = "/")
for (f in old)
  try (read.spc (f))

## all other files should be good for import
other <- setdiff (Sys.glob ("spc/*.[sS][pP][cC]"), old)
for (f in other){
  spc <- read.spc (f)

  if (is (spc, "hyperSpec"))
    cat (f, ": ", nrow (spc), " spectrum(a), ", nwl (spc), " data pts / spc.\n", sep = "")
  else
    cat (f, ": list of ", length (spc), " spectra, ", 
         paste (range (sapply (spc, nwl)), collapse = " - "), 
         " data pts / spc\n", sep = "")
}
@

The header and subheader blocks of spc files store additional information of pre-defined types (see the file format specification\cite{Galactic1997}). Further information can be stored in the so-called log block at the end of the file, and should be in a key-value format (although even the official example files do not always). 
This information is often useful (Kaiser's Hologram software \eg stores the stage position in the log block).

\Rfunction{read.spc} has four arguments that allow fine-grained control of storing such information in the \chy object:
\begin{labeling}{\Rcode{keys.hdr2data}}
\item[\Rcode{keys.hdr2data}] parameters from the spc file and subfile headers that should become extra data columns
\item[\Rcode{keys.hdr2log}] parameters from the spc file and subfile headers that should be stored as list entries in the \Rfunarg{long.description} of the log entry
\item[\Rcode{keys.log2data}] parameters from the spc file log block that should become extra data columns
\item[\Rcode{keys.log2log}] parameters from the spc file log block that should be stored as list entries in the \Rfunarg{long.description} of the log entry
\end{labeling}
The value of these arguments can either be logical (amounting to either use all or none of the information in the file) or a character vector giving the names of the parameters that should be used. Note that the header file field names are always lowercase, while the log entries are treated case sensitive.

.spc files may contain multiple spectra that do \emph{not} share a common wavelength axis. In this case, \Rfunction{read.spc} returns a list of \chy objects with one spectrum each. \Rfunction{rbind.fill} may be used to combine this list into one \chy object:
<<read.spc.list>>=
spc <- read.spc ("spc/BARBITUATES.SPC")
class (spc)
length (spc)
spc <- do.call (rbind.fill.hyperSpec, spc)
spc
spc [[1:10, , 25 ~ 30]]
@
<<spclistplot, fig = TRUE>>=
 levelplot (spc ~ .wavelength * z, spc, panel = panel.leveldotplot, cex = .3,
            col.regions = colorRampPalette (c ("orange", "darkred")))
@


\paragraph{Deriving manufacturer specific import filters.}
Please note that future changes inside the read.spc function are likely to occur. 
However, if you just post-process the \chy object returned by \Rfunction{read.spc}, you should be fine.

\section{Manufacturer-Specific Discussion of File Import}
\subsection{Manufacturer Specific Import Functions}

Many spectrometer manufacturers provide a function to export their
spectra into ASCII files. The functions discussed above are written in a very general way, and are
highly customizable.
I recommend wrapping these calls with the appropriate settings for
your spectra format in an import function. You may also consider contributing
such import filters to \Rpackage{hyperSpec}: send me \mailme
the documented code (either .R + .Rd file or Roxygen commented .R).

If you are able to import data of any format not mentioned in this document (even without the need of
new converters), please let me know (see the box at the beginning of this document). 

\subsection{Bruker FT-IR Imaging}
\label{sec:read.ENVI.Bruker}

<<echo = FALSE, results = tex>>=
make.all.permutations ("ENVI", "Infrared", "Bruker")
make.all.permutations ("ENVI", "Map", "Bruker")
@

We use \Rfunction{read.ENVI} to import IR-Images collected with a Bruker Hyperion spectrometer with
OPUS software. As mentioned above, the header files are frequently missing. We found the necessary
information to be:
<<eval=FALSE>>=
header <- list (samples = 64 * no.images.in.row,
                lines = 64 * no.images.in.column,
                bands = no.data.points.per.spectrum,
                `data type` = 4,
                interleave = "bip")
@
No spatial information is given in the ENVI header (if written). The lateral coordinates can be setup
by specifying origin and pixel size for $x$ and $y$ directions. For details please see the help page.

The proprietary file format of the Opus software is not (yet) supported.

\subsection{Nicolet FT-IR Imaging}
\label{sec:read.ENVI.Nicolet}
<<echo = FALSE, results = tex>>=
make.all.permutations ("ENVI", "Infrared", "Nicolet")
@

Also Nicolet saves imaging data in ENVI files. These files use some non-standard keywords in the
header file that should allow to reconstruct the lateral coordinates as well as the wavelength axes and units for wavelength and intensity axis. \phy has a specialized function \Rfunction{read.ENVI.Nicolet} that uses these header entries.

It seems that the position of the first spectrum is recorded in \mum{}, while the pixel size is in
mm. Thus a flag \Rfunarg{nicolet.correction} is provided that divides the pixel size by 1000. 
Also here, giving the correct offset and pixel size values as function arguments is possible.

<<readENVINicolet>>=
spc <- read.ENVI.Nicolet ("ENVI/example2.img", nicolet.correction = TRUE) 
spc ## dummy sample with all intensities zero
@

\subsection{Kaiser Optical Systems Raman}
\label{sec:Kaiser}

<<echo = FALSE, results = tex>>=
make.all.permutations ("spc", "Raman", "Kaiser")
make.all.permutations ("hol", "Raman", "Kaiser")
@

Spectra obtained using Kaiser's Hologram software can be saved either in their own .hol format and
imported into Matlab (from where the data may be written to a .mat file readable by
\Rpackage{R.matlab}'s \Rfunction{readMat}. Alternatively, Hologram can write ASCII files and .spc
files. We found working with .spc files the best option. 

The spectra are usually interpolated to an evenly spaced wavelength (or $\Delta\tilde\nu$) axis
unless the spectra are saved in a by-pixel manner.

\subsubsection{Kaiser Optical Systems ASCII Files}
\label{sec:KaiserASCII}

<<echo = FALSE, results = tex>>=
make.all.permutations ("ASCII long", "Raman", "Kaiser")
@
The ASCII files are long format that can be imported by \Rfunction{read.txt.long} (see
section~\ref{sec:read.txt.long}, p.~\pageref{sec:read.txt.long}). 

We experienced two different problems with these files:
\begin{enumerate}
\item If the instrument computer's locale is set so that also the decimal separator is a comma,  
commas are used both as decimal and as column separator.
\item Values with a decimal fraction of $0$ are written as e.g. \texttt{2,}. This may be a problem
for certain conversion functions. 
\end{enumerate}
Problems may arise 

Still the files may be imported, though care must be taken:
<<Kaiser.txt.comma>>=
## 1. import as character
tmp <- scan ("txt.Kaiser/test-lo-4.txt", what = rep ("character",4), sep = ",")
tmp <- matrix (tmp, nrow = 4)

## 2. concatenate every two columns by a dot
wl <- apply (tmp [1:2, ], 2, paste, collapse = '.')
spc <- apply (tmp [3:4, ], 2, paste, collapse = '.')

## 3. convert to numeric and create hyperSpec object
spc <- new ("hyperSpec", spc = as.numeric (spc), wavelength = as.numeric (wl))
@

\subsubsection{Kaiser Optical Systems Raman Maps}
\label{sec:read.spc.KaiserMap}
<<echo = FALSE, results = tex>>=
make.all.permutations ("spc", "Raman", "Kaiser")
make.all.permutations ("spc", "Kaiser", "Map")
@

Spectra obtained using Kaiser's Hologram software can be saved either in their own .hol format and
imported into Matlab (from where the data may be written to a .mat file readable by
\Rpackage{R.matlab}'s \Rfunction{readMat}. Alternatively, Hologram can write ASCII files and .spc
files. We found working with .spc files the best option. 

\phy provides the function \Rfunction{read.spc.KaiserMap} to easily import spatial collections of
.spc files written by Kaiser's Hologram software. The filenames of all .spc files to be read into one
\chy object can be provided either in a character vector or as a wildcard expression (\eg
\textquotedbl path/to/files/*.spc\textquotedbl ).

The data for the following example was saved with wavelength axis camera pixels rather than Raman
shift. Thus two files for each spectrum (one low wavenumber region, one high wavenumber region) were
saved by Hologram. Thus, a file name pattern is difficult to give and consequently a vector of file
names is used instead:
<<readspcKaiserMap, fig = TRUE>>=
files <- Sys.glob ("spc.KaiserMap/*.spc")
spc.low <- read.spc.KaiserMap (files [seq (1, length (files), by = 2)])
spc.high <- read.spc.KaiserMap (files [seq (2, length (files), by = 2)])
wl (spc.high) <- wl (spc.high) + 1340
plot (cbind (spc.low, spc.high))
@

\subsection{Renishaw Raman}
\label{sec:scan.txt.renishaw}
<<echo = FALSE, results = tex>>=
make.all.permutations ("Raman", "Renishaw")
make.all.permutations ("spc", "Raman", "Renishaw")
@

Renishaw's Wire software comes with an file format converter. This program can produce a long ASCII
format, .spc, or .jdx files.

We experienced that the conversion to .spc is \emph{not} fully reliable: maps were saved as depth
profile, loosingall spatial information. Also, an evenly spaced wavelength axis was produced,
although this was de-selected in the converter. We therefore recommend using the ASCII format.
Otherwise the import using \Rfunction{read.spc} worked.

\subsubsection{Renishaw ASCII data}
\label{sec:scan.txt.Renishaw}
<<echo = FALSE, results = tex>>=
make.all.permutations ("ASCII long", "Raman", "Renishaw")
@
An optimized import function for the ASCII files is available: \Rfunction{scan.txt.Renishaw}.
The ASCII files can easily become very large, particularly with linefocus- or streamline imaging. 
\Rfunction{scan.txt.Renishaw} provides two mechanisms to avoid running out of memory during data
import. First of all, the file may be imported in chunks (of a given number of lines). Secondly, the
processing of the long ASCII format into the spectra matrix is done by reshaping the vector of
intensities into a matrix. This process does not allow any missing values in the data.
\emph{Therefore it is not possible to import multi-spectra files with individually ``zapped''
spectra.}

The second argument to  \Rfunction{scan.txt.Renishaw} decides what type of experiment is imported.
Supported types are:
\begin{labeling}{\Rcode{\textquotedbl depth\textquotedbl}, \Rcode{\textquotedbl zspc\textquotedbl}}
\item[\Rcode{\textquotedbl xyspc\textquotedbl}] maps, images, multiple spectra with $x$ and $y$
coordinates (default)
\item[\Rcode{\textquotedbl spc\textquotedbl}] single spectrum
\item[\Rcode{\textquotedbl depth\textquotedbl}, \Rcode{\textquotedbl zspc\textquotedbl}] depth series
\item[\Rcode{\textquotedbl ts\textquotedbl}] time series
\end{labeling}

<<scan.txt.Renishaw>>=
scan.txt.Renishaw ("txt.Renishaw/paracetamol.txt", "spc")
scan.txt.Renishaw ("txt.Renishaw/laser.txt", "ts")
scan.txt.Renishaw ("txt.Renishaw/chondro.txt", nlines = 1e5, nspc = 875)
@


\section{Writing your own Import Function}
\label{sec:writing-Import}
This section gives examples  how to write import functions. The first example implements an import
filter for an ASCII file format basically from scratch. The second example shows how to implement more details for an already existing import filter. 

\subsection{A new ASCII Import Function: scan.txt.PerkinElmer}
\label{sec:read.txt.PerkinElmer}
<<echo = FALSE, results = tex>>=
make.all.permutations ("ASCII long", "Fluorescence", "Perkin Elmer")
@
The raw spectra of the \Robject{flu} data set (see also the respective vignette) are in Perkin
Elmer's ASCII file format, one spectrum per file. 

We need a function that automatically reads all files specified by a pattern, such as \texttt{*.txt}.
In order to gain speed, the spectra matrix should be preallocated after the first file is read. 

A short examination of the files (\texttt{flu*.txt} in directory \texttt{txt.PerkinElmer}) reveals
that the actual spectrum starts at line 55, after a line containing \texttt{\#DATA}.
For now, no other information of the files is to be extracted. It is thus easier to skip the first 54
lines than searching for the line after \texttt{\#DATA}. 

A fully featured import function should support:
\begin{itemize}
\item Reading multiple files by giving a pattern
\item hand further arguments to \Rfunction{scan}. This comes handy in case the function is used later
to import other data types.
\item Also skipping 54 lines would be a weird default, so we rather require it to be given
explicitly.
\item The same applies for the axis labels: they should default to reasonable settings for
fluorescence spectra, but it should be possible to change them if needed.
\item The usual log entry arguments should be supplied.
\item A sanity check should be implemented: stop with an error if a file does not have the same
wavelength axis as the others.
\item Finally, if no file can be found, an empty \chy object is a reasonable result: There is no need
to stop with an error, but it is polite to issue an additional warning.
\end{itemize}

\VerbatimInput[frame=single, label={scan.txt.PerkinElmer.R},
formatcom=\footnotesize]{scan.txt.PerkinElmer.R}

Note how the labels are set. The label with the special name \Rcode{.wavelength} corresponds to the
wavelength axis, all data columns should have a label with the same name. The spectra are always in a
data column called \Rcode{spc}.

Thus,
<<scan.txt.PerkinElmer>>=
source ("scan.txt.PerkinElmer.R")
scan.txt.PerkinElmer ("txt.PerkinElmer/flu?.txt", skip = 54)
@
imports the spectra.

This function is not exported by \phy. While it is already useful for importing files, it is not yet general enough to work immediately with new data. The the file header is completely ignored.

\subsection{Deriving a More Specific Function: read.ENVI.Nicolet}

<<echo = FALSE, results = tex>>=
make.all.permutations ("ENVI", "Infrared", "Nicolet")
make.all.permutations ("ENVI", "Infrared", "Map")
make.all.permutations ("ENVI", "Map", "Nicolet")
@

The function \Rfunction{read.ENVI.Nicolet} is a good example for a more specific import filter
derived from a general filter for the respective file type.
Nicolet FT-IR Imaging software saves some non-standard key-words in the header file of the ENVI data.
These information can be used to reconstruct the $x$ and $y$ axes of the images. The units of the
spectra are saved as well.

\Rfunction{read.ENVI.Nicolet} thus first adjusts the parameters for \Rfunction{read.ENVI}. Then
\Rfunction{read.ENVI} does the main work of importing the file. The resulting \chy object is 
post-processed according to the special header entries.

For using the function, see section~\ref{sec:read.ENVI.Nicolet}~(p.~\pageref{sec:read.ENVI.Nicolet}).
\VerbatimInput[frame=single, label={read.ENVI.Nicolet.R},
formatcom=\footnotesize]{read.ENVI.Nicolet.R}

\subsection{Deriving import filters for spc files}
Please note that future changes inside the read.spc function are likely to occur. 
However, if you just post-process the \chy object returned by \Rfunction{read.spc}, you should be fine.

\bibliographystyle{unsrtnat}
\bibliography{FileIO-pkg,FileIO}
<<citations, echo = FALSE>>=
make.bib ("R.matlab", file = "FileIO-pkg.bib")
@

\clearpage
\appendix
\section{File Import  Functions by Format}
\label{sec:format}
\renewcommand{\arraystretch}{1.5}
\begin{footnotesize}
  \begin{tabular}{@{} l l l l >{\raggedright}p{3.4cm}}
  \textbf{Format} & 
  \textbf{Manufacturer} & 
  \textbf{Function} & 
  \textbf{section}  & 
  \textbf{Notes}\tabularnewline
  \multicolumn{4}{@{}l}{\emph{\textbf{ASCII file formats}}}\tabularnewline
<<results=tex, echo = FALSE>>=
fileformats <- read.table ("fileformats.org", header = TRUE, sep = "|", strip.white=TRUE)
fileformats <- fileformats [, ! apply (is.na (fileformats), 2, all)]

i <- order (fileformats$Name)
res <- apply (fileformats [i,][fileformats$Type [i] == "ASCII",], 1, 
       function (x) {
         cat (x [2], "&", x [3])
         if (nchar (x [4]) > 0)
           cat (" (", x[4],  ")", sep = "")
         cat (" & \\Rfunction{", x[5], "} & \\ref{sec:", x[6], "}, p. \\pageref{sec:", 
              x[6],"} & ", x [7], "\\tabularnewline\n",
              sep = "")
       })
@
\multicolumn{4}{@{}l}{\emph{\textbf{binary file formats}}}\tabularnewline
<<results=tex, echo = FALSE>>=
res <- apply (fileformats [i,][fileformats$Type [i] == "binary",], 1, 
       function (x) {
         cat (x [2], "&", x [3])
         if (nchar (x [4]) > 0)
           cat (" (", x[4],  ")", sep = "")
         cat (" & \\Rfunction{", x[5], "} & \\ref{sec:", x[6], "}, p. \\pageref{sec:", 
              x[6],"} & ", x [7], "\\tabularnewline\n",
              sep = "")
       })
@
\end{tabular}
\end{footnotesize}

\section{File Import  Functions by Manufacturer}
\label{sec:manufacturer}
\begin{footnotesize}
\begin{tabular}{@{} l l l l >{\raggedright}p{3.4cm}}
  \textbf{Manufacturer} & 
  \textbf{Format} & 
  \textbf{Function} & 
  \textbf{section}  & 
  \textbf{Notes}\tabularnewline
\multicolumn{4}{l}{\emph{\textbf{Manufacturers}}}\tabularnewline
<<results=tex, echo = FALSE>>=
i <- order (fileformats$Manufacturer)
res <- apply (fileformats [i,][fileformats$Manufacturer [i] != "",], 1, 
       function (x) {
         cat (x [3])
         if (nchar (x [4]) > 0)
           cat (" (", x[4],  ")", sep = "")
         cat ("&", x [2], " & \\Rfunction{", x[5], "} & \\ref{sec:", x[6], 
              "}, p. \\pageref{sec:", x[6],"} & ", x [7], "\\tabularnewline\n",
              sep = "")
       })
@
\end{tabular}
\end{footnotesize}
\section{File Import Functions by Spectroscopy}
\label{sec:spectroscopy}
\begin{footnotesize}
\begin{tabular}{@{} l l l l l >{\raggedright}p{2.7cm}}
  \textbf{Spectroscopy} & 
  \textbf{Format} & 
  \textbf{Manufacturer} & 
  \textbf{Function} & 
  \textbf{section}  & 
  \textbf{Notes}\tabularnewline
<<results=tex, echo = FALSE>>=
i <- order (fileformats$Spectroscopy, tolower (fileformats$Name))
res <- apply (fileformats [i,][fileformats$Spectroscopy [i] != "",], 1, 
       function (x) {
         if (nchar (x [4]) > 0) cat (x[4])
         cat ( "&", x [2], "&", x [3])
         cat (" & \\Rfunction{", x[5], "} & \\ref{sec:", x[6], "}, p. \\pageref{sec:", 
              x[6],"} & ", x [7], "\\tabularnewline\n",
              sep = "")
       })
@
\end{tabular}
\end{footnotesize}

\printindex
<<cleanup, echo = FALSE, results = hide>>=
rm (list = ls () ) 
@ 
\end{document}


