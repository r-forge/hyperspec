%% LyX 1.6.2 created this file.  For more info, see http://www.lyx.org/.
%% Do not edit unless you really know what you are doing.
\documentclass[a4paper,english,a4paper, 10pt, smallheadings, DIV15]{scrartcl}
\usepackage[T1]{fontenc}
\usepackage[utf8x]{inputenc}
\setlength{\parskip}{\medskipamount}
\setlength{\parindent}{0pt}
\usepackage{color}
\usepackage{babel}

\usepackage{textcomp}
\usepackage{url}
\usepackage{relsize}
\usepackage{graphicx}
\usepackage[unicode=true,
 bookmarks=true,bookmarksnumbered=false,bookmarksopen=false,
 breaklinks=false,pdfborder={0 0 1},backref=false,colorlinks=true]
 {hyperref}
\hypersetup{pdftitle={Chondro },
 pdfauthor={Claudia Beleites},
 pdfsubject={Vignette on hyperSpec's chondro data set},
 pdfkeywords={chondro, hyperSpec, cluster analysis, preprocessing, Raman, principal component analysis, PCA}}

\makeatletter

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% LyX specific LaTeX commands.
\DeclareRobustCommand{\greektext}{%
  \fontencoding{LGR}\selectfont\def\encodingdefault{LGR}}
\DeclareRobustCommand{\textgreek}[1]{\leavevmode{\greektext #1}}
\DeclareFontEncoding{LGR}{}{}

\DeclareRobustCommand{\lyxmathsym}[1]{\ifmmode\begingroup\def\b@ld{bold}
  \def\rmorbf##1{\ifx\math@version\b@ld\textbf{##1}\else\textrm{##1}\fi}
  \mathchoice{\hbox{\rmorbf{#1}}}{\hbox{\rmorbf{#1}}}
  {\hbox{\smaller[2]\rmorbf{#1}}}{\hbox{\smaller[3]\rmorbf{#1}}}
  \endgroup\else#1\fi}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% Textclass specific LaTeX commands.
\usepackage{Sweave}

\newcommand{\Rcode}[1]{{\texttt{#1}}}
\newcommand{\Robject}[1]{{\texttt{#1}}}
\newcommand{\Rcommand}[1]{{\texttt{#1}}}
\newcommand{\Rfunction}[1]{{\texttt{#1}}}

\newcommand{\Rfunarg}[1]{{\textit{#1}}}
\newcommand{\Rpackage}[1]{{\textit{#1}}}
\newcommand{\Rmethod}[1]{{\textit{#1}}}
\newcommand{\Rclass}[1]{{\textit{#1}}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User specified LaTeX commands.
% Meta information - fill between {} and do not remove %
% \VignetteIndexEntry{Vignette on the chondro data set. Shows common Preprocessing tasks for Raman spectra, principal component analysis (PCA), and hierarchical cluster analysis.}
% \VignetteKeywords{chondro, hyperSpec, cluster analysis, preprocessing, Raman, principal component analysis, PCA}
% \VignettePackage{hyperSpec}
\AtBeginDocument{
\fvset{listparameters={\setlength{\topsep}{0pt}}}
\renewenvironment{Schunk}{\vspace{\topsep}\begin{small}}{\end{small}\vspace{\topsep}
}
\SweaveOpts{pgf = FALSE, eps = FALSE, external = FALSE, pdf = TRUE, keep.source = TRUE, strip.white = TRUE}
}

% my preferred packages
\usepackage{xspace}

\newcommand{\rcm}[1]{\ensuremath{#1} \mathrm{cm^{-1}}\xspace}
\newcommand{\code}[1]{\nohyphens{\texttt{#1}}\xspace}

\@ifundefined{showcaptionsetup}{}{%
 \PassOptionsToPackage{caption=false}{subfig}}
\usepackage{subfig}
\makeatother

\begin{document}

\title{Raman Spectra of Chondrocytes in Cartilage:\\
\Rpackage{hyperSpec}'s \Robject{chondro} data set}


\author{Claudia Beleites (\url{cbeleites@units.it})\\
CENMAT, DMRN, University of Trieste}

\maketitle
<<startup, echo = FALSE, results = hide>>=
#setwd ("~/Uni/workspace/hyperspec.rforge/Vignettes/chondro")
options(SweaveHooks=list(fig=function() par(mar = c (4.1, 4.1, .6, .6))))
options ("width" = 100)
library (hyperSpec)
@


\section{Introduction}

This vignette describes the \Robject{chondro} data set. It shows
a complete data analysis work flow on a Raman map demonstrating frequently
needed preprocessing methods
\begin{itemize}
\item baseline correction
\item normalization
\item smoothing / interpolating spectra
\item plotting spectra
\item plotting false color maps
\end{itemize}
and other basic work techniques
\begin{itemize}
\item cutting the spectral range,
\item selecting (extracting) or deleting spectra, and
\item \emph{aggregating} spectra (e.g. calculating cluster mean spectra).
\end{itemize}
The chemometric methods used are
\begin{itemize}
\item Principal Component Analysis (PCA) and
\item hierarchical cluster analysis,
\end{itemize}
showing how to use data analysis procedures provided by R and other
packages.


\section{The Data Set}

%
\begin{figure}[tbh]
\noindent \begin{centering}
\includegraphics[width=0.5\textwidth]{080606d-flip-ausw}
\par\end{centering}

\caption{\label{fig:vis-all}Microscope view of the cartilage section. The
frame indicates the measurement area (35 $\times$21 μm).}



\end{figure}
Raman spectra of a cartilage section were measured on each point of
a grid, resulting in a so-called \emph{Raman map}. Figure~\ref{fig:vis-all}
shows a microscope picture fo the measuarea and its surroundings.

The measurement parameters were:
\begin{description}
\item [{Excitation~wavelength:}] 633 nm
\item [{Exposure~time:}] 10 s per spectrum
\item [{Objective:}] 100$\times$, NA 0.85
\item [{Measurement~grid:}] 35 $\times$21 μm, 1 μm step size
\item [{Spectrometer:}] Renishaw InVia
\end{description}
All data to reproduce this Vignette is accessible at \Rpackage{hyperSpec}'s
homepage, \url{http://r-forge.r-project.org/projects/hyperspec/},
as the original file is far too large to be included in the package.


\section{Data Import}

Renishaw provides a converter to export their proprietary data in
a so-called long format ASCII file. Raman maps are exported having
four columns, \emph{y}, \emph{x}, \emph{raman shift}, and \emph{intensity}.
\Rpackage{hyperSpec} comes with a function to import such files,
\Rfunction{scan.txt.Renishaw}. The function assumes a map as default,
but can also handle single spectra (\Rcode{data = \textquotedbl{}spc\textquotedbl{}}),
time series (\Rcode{data = \textquotedbl{}ts\textquotedbl{}}), and
depth profiles (data = \textquotedbl{}depth\textquotedbl{}). In addition,
large files may be processed in chunks. In order to speed up the reading
\Rfunction{scan.txt.Renishaw} does not allow missing values, but
it does work with \Rcode{NA}.

<<import>>=
chondro <- scan.txt.Renishaw ("chondro.txt", data = "xyspc")
chondro
@

To get an overview of the spectra, :

<<fig-rawspc, fig = TRUE, width = 7.5, height = 5, include = FALSE>>=
plot (chondro, "spcprctl5")
@

A sum intensity map is produced by:

<<fig-rawmap, fig = TRUE, width = 7.5, height = 5, include = FALSE>>=
print (plotmap (chondro, na.rm = TRUE))
@

Figure~\ref{fig:raw} shows the results.

%
\begin{figure}[tbh]
\subfloat[The raw spectra: median, 16\textsuperscript{th} and 84\textsuperscript{th},
and 5\textsuperscript{th} and 95\textsuperscript{th} percentile
spectra.]{\includegraphics[width=0.5\textwidth]{chondro-fig-rawspc}



}\subfloat[The sum intensity of the raw spectra.]{\includegraphics[width=0.5\textwidth]{chondro-fig-rawmap}



}

\caption{\label{fig:raw} The raw data.}



\end{figure}



\section{Preprocessing}

As usual in Raman spectroscopy of biological tissues, the spectra
need some preprocessing.


\subsection{Spectral Smoothing}

As the overview print shows that the spectra contain \Rcode{NA}s
(from cosmic spike removal that was done previously), the first step
is to remove these. Another issue that can be solved at the same time
is that the wavelength axis is not evenly spaced (the data points
are between \Sexpr{signif (min (diff (wl (chondro))), 2)} and \Sexpr{signif (max (diff (wl (chondro))), 2)}
cm\textsuperscript{-1} apart from each other). Furthermore, it would
be good to trade some spectral resolution for hgher signal to noise
ratio. All three of these issues are tackled by interpolating and
smoothing of the wavelength axis by \Rfunction{spc.loess}. The resolution
is to be reduced to 8 cm\textsuperscript{-1}, or 4 cm\textsuperscript{-1}
data point spacing.

<<interp>>=
chondro <- spc.loess (chondro, seq (602, 1800, 4))
chondro
@


\subsection{Baseline Correction}

Next, we do a linear baseline correction. \Rfunction{spc.fit.poly.below}
tries to automatically find appropriate support points for polynomial
baselines. The default is a linear baseline, which is appropriate
in our case:

<<bl>>=
baselines <- spc.fit.poly.below (chondro)
chondro <- chondro - baselines
@

%
\begin{figure}[tbh]
\subfloat[\label{fig:bl-bl}The spectra after smoothing, baseline correction,
and normalization.]{\includegraphics[width=0.49\textwidth]{chondro-norm}}\subfloat[\label{fig:bl:perc} The spectra after substracting the 5\textsuperscript{th}
percentile spectrum.]{\includegraphics[width=0.49\textwidth]{chondro-perc}}\caption{\label{fig:bl}The preprocessed spectra.}

\end{figure}



\subsection{Normalization}

As the spectra are quite similar, area normalization should work well:.

<<norm, fig = TRUE, width = 7.5, height = 5, include = FALSE>>=
chondro <- sweep (chondro, 1, apply (chondro, 1, mean), "/")
plot (chondro, "spcprctl5")
@

For the results of these preprocessing steps, see figure~\ref{fig:bl-bl}.


\subsection{Substracting the Overall Composition}

The spectra are very homogeneous, but I'm interested in the differences
between the different regions of the sample. Sustracting the minimum
spectrum cancels out the matrix compositon that is common to all spectra.
But the minimum spectrum also picks up a lot of noise. So instead,
the 5\textsuperscript{th} percentile spectrum is substracted:

<<perc, fig = TRUE, width = 7.5, height = 5, include = FALSE>>=
chondro <- sweep (chondro, 2, apply (chondro, 2, quantile, 0.05), "-")
plot (chondro, "spcprctl5")
@

The resulting data set is shown in figure~\ref{fig:bl:perc}. Some
interesting differences start to show up: there are distinct lipid
bands in some but not all of the spectra.


\subsection{Outlier Removal by Principal Component Analysis (PCA)}

PCA is a technique that decomposes the data into scores and loadings
(virual spectra). It is known to be quite sensitive to outliers. Thus,
I use it for outlier detection. The resulting scores and loadings
are put again into \Rclass{hyperSpec} objects by \Rfunction{decomposition}:

<<pca>>=
pca <- prcomp (~ spc, data = chondro$., center = TRUE)
scores <- decomposition (chondro, pca$x, label.wavelength = "PC", label.spc = "score / a.u.")
loadings <- decomposition (chondro, t(pca$rotation), scores = FALSE, label.spc = "loading I / a.u.")
@

Plotting the scores of each PC against all other gives a good idea
where to look for outliers.

<<pca-pairs, eval = FALSE>>=
pairs (scores [[,,1:20]], pch = 19, cex = 0.5)
@

Now the spectra can be found either by plotting two scores against
each other (by \Rfunction{plot}) and identifying with \Rfunction{identify},
or they can be identified in the score map by \Rfunction{map.identify}.
There is also a function to identify spectra in a spectra plot, \Rfunction{spc.identify},
but this is not helpful here.

<<pca-identify, eval = FALSE>>=
out <- map.identify (scores [,,5])
out <- c (out, map.identify (scores [,,6]))
out <- c (out, map.identify (scores [,,7]))
@

<<pca-out, echo = FALSE, results = hide>>=
out <- c(105, 140, 216, 289, 75, 69)
@

<<pca-cols>>=
out
outcols <- c ("red", "blue", "#800080", "orange", "magenta", "brown")

cols <- rep ("black", nrow(chondro))
cols [out] <- outcols
@

We can check our findings by comparing the spectra to the bulk of
spectra (figure~):

<<pca-outspc, fig = TRUE, width = 7.5, height = 7.5, include = FALSE>>=
plot(chondro[1], plot.args = list (ylim = c (1, length (out) + .7)), lines.args = list(  type = "n"))
for (i in seq (along = out)){
   plot(chondro, "spcprctl5", yoffset = i, add = TRUE, col = "gray")
   plot (chondro [out[i]], yoffset = i, col = outcols[i] , add = TRUE, lines.args = list (lwd = 2))
   text (600, i + .33, out [i])  }
@

and also by looking where these spectra appear in the scores \Rfunction{pairs}
plot (figure~):

<<pca-pairs2, fig = TRUE, width = 7.5, height = 7.5, include = FALSE>>=
pairs (scores [[,,1:7]], pch = 19, cex = 1, col = cols)
@

Finally, the outliers are removed:

<<outdel>>=
chondro <- chondro [- out]
@

%
\begin{figure}[tbh]
\subfloat[\Rfunction{pairs} plot of the first 7 scores.]{\includegraphics[width=0.495\textwidth]{chondro-pca-pairs2}

}\subfloat[The suspected outlier spectra.]{\includegraphics[width=0.495\textwidth]{chondro-pca-outspc}}\caption{Outlier removal by PCA}

\end{figure}



\section{Hierarchical Cluster Analysis (HCA)}

HCA fuses objects according to their (dis)similarity. The result is
a dendrogram, a graph stating at which level two objects are similar
and thus grouped together.

The first step in HCA is the choice of the distance. The R function
\Rfunction{dist} offers a variety of distance measures to be computed.
The so-called \textsc{Pearson} distance \global\long\def\COR{COR}
$D\lyxmathsym{\texttwosuperior}_{Pearson}=\frac{1-\COR\left(X\right)}{2}$
is popular in data analysis of vibrational spectra and is provided
by \Rpackage{hyperSpec}.

Also for computing the dendrogram, a number of choices are available.
I choose \textsc{Ward}'s method, and, as it uses \textsc{Euclid}ean
distance for calculating the dendrogram, \textsc{Euclid}ean distance
also for the distance matrix :

<<hca>>=
dist <- dist (chondro [[]])
dendrogram <- hclust (dist, method = "ward")
@

<<denddummy, eval = FALSE>>=
plot (dendrogram)
@

In order to get clusters, the dendrogram is cut at a level specified
either by height or by the number of clusters. The result for $k$=
3 clusters is plot as a map. If \Rfunction{plotmap}'s \Rfunarg{z}
is a factor, the legend bar does not show intermediate colors.

<<clustmap, fig = TRUE, width = 7.5, height = 5, include = FALSE>>=
clusters <- cutree (dendrogram, k = 3)
print (plotmap (chondro, z = as.factor (clusters)))
@

The cluster membership can also be marked in the dendrogram:

<<dend, fig = TRUE, width = 7.5, height = 5, include = FALSE>>=
plot (dendrogram, labels = FALSE, hang = 0)
col.clust <- matlab.palette(3)
points (seq_along (dendrogram$order), rep (-3, length (dendrogram$order)),
        col = col.clust [clusters [dendrogram$order]], pch = "|")
@

Figure~\ref{fig:dend} shows the dendrogram and \ref{fig:clustmap}
the resulting cluster map. The three clusters correspond to the cartilage
matrix, the lacuna and the cells. The left cell is destroyed and its
contents are leaking into the matrix, while the right cells looks
intact.

We can calculate the cluster mean spectra using \Rfunction{aggregate}.
However, we can do even better and plot the cluster mean spectra $\pm$
1 standard deviation (see figure~\ref{fig:clustmeans}):

<<clustmeans, fig = TRUE, width = 7.5, height = 5, include = FALSE>>=
cluster.means <- aggregate (chondro, clusters, mean_pm_sd)
plot(cluster.means, yoffset = rep ((1:3), each = 3), col = rep (matlab.palette (3), each = 3))
@

%
\begin{figure}[tbh]
\subfloat[\label{fig:dend} The dendrogram.]{\includegraphics[width=0.495\textwidth]{chondro-dend}}\subfloat[\label{fig:clustmap} The cluster map for $k=3$ clusters.]{\includegraphics[width=0.495\textwidth]{chondro-clustmap}}\caption{Hierarchical cluster analysis.}

\end{figure}



\section{Plotting a False-Colour Map of Certain Spectral Regions}

\Rclass{hyperSpec} comes with a sophisticated inferface for specifying
spectral ranges. Expressing things like 1000~cm\textsuperscript{-1}
$\pm$~1 data points are easily possible. Thus, we can have a fast
look at the nucleic acid distribution, using the DNA bands at 728,
782, 1098, 1240, 1482, and 1577~cm\textsuperscript{-1}:

<<DNA, fig = TRUE, width = 7.5, height = 5, include = FALSE>>=
print (plotmap (chondro[, , c( 728 - 1i ~  728 + 1i,
                               782 - 1i ~  782 + 1i,
                              1098 - 1i ~ 1098 + 1i,
                              1240 - 1i ~ 1240 + 1i,
                              1482 - 1i ~ 1482 + 1i,
                              1577 - 1i ~ 1577 + 1i)]))
@

The result is shown in figure~\ref{fig:DNA}. While the nucleus of
the right cell shows up nicely, nothing is detected in the remainders
of the left cell.

%
\begin{figure}[tbh]
\subfloat[\label{fig:clustmeans} The cluster mean $\pm$ 1 standard deviation
spectra. The blue cluster shows distinct lipid bnds, the green cluster
collagen, and the red cluster proteins and nucleic acids.]{\includegraphics[width=0.495\textwidth]{chondro-clustmeans}

}\subfloat[\label{fig:DNA} False colour map of the DNA band intensities.]{\includegraphics[width=0.495\textwidth]{chondro-DNA}

}

\caption{}

\end{figure}

\end{document}
