% -*- mode: noweb; noweb-default-code-mode: R-mode; -*- 
\documentclass[english, a4paper, 10pt, headings=small, DIV11]{scrartcl}
\usepackage{longtable}

\SweaveInput{vignettes.defs}
\hypersetup{pdftitle={hyperSpec Introduction},
 pdfauthor={C. Beleites},
 pdfsubject={Introduction on the R package hyperSpec},
 pdfkeywords={hyperSpec}}

% \VignetteIndexEntry{hyperSpec Introduction}
% \VignetteKeywords{hyperspec}
% \VignettePackage{hyperSpec}

\begin{document}
\title{\Rpackage{hyperSpec} Introduction }
\maketitle
\warnbox{Reproducing the Examples in this Vignette}{
All spectra used in this manual are installed automatically with \phy. 

The source data files of the \Robject{flu} and \Robject{laser} data sets as well as of the paracetamol spectrum are shipped with the package.
For reproducing the examples in a live session, the full file names of the 
spectra can be found with the command:\\
\texttt{\small\textsl{> Sys.glob (paste (.libPaths (),
"hyperSpec/doc/rawdata/*.txt", sep = "/"))}} \\
Note that some definitions are executed in \texttt{vignette.defs}.

The source data file of the \Robject{chondro} data, however, needs to be be obtained separately. It is available for download as a .zip file at \Rpackage{hyperSpec}'s home page  (\url{http://r-forge.r-project.org/projects/hyperspec/}, ca. 8.5 MB).
The original file (ca. 31 MB) is far too large to be included in the package.
}

\tableofcontents{}

\section{Introduction}

\Rpackage{hyperSpec} is a R package that allows convenient handling
of (hyper)spectral data sets, \ie data sets comprising spectra
together with further data on a per-spectrum basis. The
spectra can be anything that is recorded over a common discretized
axis, the \emph{so-called} wavelength axis. Throughout the documentation of the package,
the terms intensity and wavelength refer to the spectral ordinate
and abscissa, respectively.

However, \Rpackage{hyperSpec} works perfectly fine with any data
that fits in that general scheme, so that the three terms may also
be used for:
\begin{labeling}{wavelength: }
\item [wavelength:] frequency, wavenumbers, chemical shift, Raman shift,
$\frac{m}{z}$, etc.
\item [intensity:] transmission, absorbance, $\frac{e^{-}}{s}$, \textellipsis
\item [extra~data: \hfill] spatial information (spectral images, maps, or profiles),
temporal information (kinetics, time series), concentrations (calibration
series), class membership information, etc. \\
Note that there is no restriction on the number of extra data columns.
\end{labeling}
This vignette gives an introduction on basic working techniques using
the R package \Rpackage{hyperSpec}. It comes with three data sets,
\begin{labeling}{wavelength: }
\item [\Robject{chondro}] a Raman map of chondrocytes in cartilage,
\item [\Robject{flu}] a set of fluorescence spectra of a calibration
series, and
\item [\Robject{laser}] a time series of an unstable laser emission
\end{labeling}
In this vignette, all three data sets are used in an intermixed way
to illustrate appropriate procedures for different tasks.

In addition, each of the data sets is accompanied by an vignette that shows an exemplary work flow how to analyze the data.

This document describes how to accomplish spectroscopic tasks. It does not give a complete reference on particular functions. It is therefore recommended to look up the methods in R's help system using  \Rcode{?{} command}.

\subsection{Notation}

This vignette demonstrates working techniques mostly from a spectroscopic
point of view: rather than going through the functions provided by
\Rpackage{hyperSpec}, it is organized more closely on spectroscopic
tasks. However, the functions discussed are printed on the margin
for a fast overview.

In R, slots of a S4 class can be accessed directly by the \Rcommand{@}
operator. In this vignette, the notation \Rcode{@xxx} will thus mean
\emph{``slot xxx of an object''} see figure~\ref{fig:structure} on page~\pageref{fig:structure}).
%TODO vref

Likewise, named elements of a \Rclass{list}, like the columns of
a \Rclass{data.frame}, are accessed by the \Rcode{\$} operator,
and \Rcode{\$xxx} will be used for \emph{``column xxx''}, and
as an abbreviation for \emph{``column xxx of the data.frame in slot
data of the object''} see figure~\ref{fig:structure} on page~\pageref{fig:structure}) .%TODO vref


\section{Remarks on R}


\subsection{Generic Functions}

\emph{Generic Functions} are functions that apply to a wide range
of data types or classes, e.\,g. \Rmethod{plot}, \Rmethod{print},
mathematical operators, etc. These functions can be implemented in
a specialized way by each class.

\Rclass{hyperSpec} implements with a variety of such functions, see
table~\ref{tab:generic} on page~\pageref{tab:generic}.

\subsection{Functionality Can be Extended at Runtime}
The concept of functions in \R offers much flexibility. Functions may be added or changed by the user in his \emph{workspace} at any time. This is also true for methods belonging to a certain class.
Neither restart of R nor reloading of the package or anything the like is needed. At the same time, the original function is not deleted, it is just masked by the user's new function but stays accessible if the change should be reverted.

This offers the opportunity of easily writing specialized functions that are adapted to specific tasks. 

As an example, see the setup of the plotting function for the spectra matrix in section~\ref{sec:plotmat} (page~\pageref{sec:plotmat})

\subsection{Validity Checking}
S4 classes have a mechanism to define and enforce that the data actually stored in the object is appropriate for this class. In other words, there is a mechanism of \emph{validity checking}. 

The functions provided by \Rpackage{hyperSpec} check the validity
of \Rclass{hyperSpec} objects at the beginning, and --- if the validity
could be broken by inappropriate arguments --- also before leaving
the function.
 
It is highly recommended to use validity checking also for user-defined functions. In addition, non-generic functions need to ensure that the argument actually is a \chy object. The two tasks are accomplished by:
<<eval = FALSE>>=
.is.hy (object)
validObject (object)
@
The first line checks whether \Robject{object} is a \chy object, the second checks its validity. 
Both functions return \Rcode{TRUE} if the checks succeed, otherwise they raise an error and stop.


\section{Loading the package}

To load \Rpackage{hyperSpec}, use
\nopagebreak
<<init>>=
library (hyperSpec)
@


\section{The structure of \Rclass{hyperSpec} objects}

\Rclass{hyperSpec} is a S4 (or new-style) class. It has four so-called
\emph{slots} that hold the data:
\begin{labeling}{@wavelength }
\item [{\Robject{@wavelength}}] containing a numeric vector with the wavelength
axis of the spectra.
\item [{\Robject{@data}}] a \Rclass{data.frame}with the spectra and all
further information belonging to the spectra
\item [{\Robject{@label}}] a list with appropriate labels (particularly
for axis annotations)
\item [{\Robject{@log}}] a \Rclass{data.frame} keeping track of what is
done with the object
\end{labeling}
However, it is good practice to use the functions provided by \Rpackage{hyperSpec}
to handle the objects rather than accessing the slots directly. This
also helps ensuring that proper (\emph{valid}) objects are retained.

Most of the data is stored in \Rcode{@data}. This \Rclass{data.frame}
has one special column, \Rcode{\$spc}. It is the column that actually
contains the spectra. The spectra are stored in a matrix inside this
column, as illustrated in figure~\ref{fig:structure}. Even if there
are no spectra, \Rcode{\$spc} must still be present but it can contain
a matrix with zero columns.

%
\begin{figure}
\noindent \centering
\include{Strukturhyperspec}
\caption{\label{fig:structure}The structure of the data in a \Rpackage{hyperSpec} object.}
\end{figure}


Slot \Rcode{@label} contains an element for each of the columns in
\Rcode{@data} plus one holding the label for the wavelength axis,
\Rcode{.wavelength}. The elements of the list may be anything suitable
for axis annotations, i.\,e. they should be either character strings
or expressions for prettier axis annotations (see figure~\ref{fig:example-plots} on page~\pageref{fig:example-plots}).
To get familiar with expressions for axis annotation, see
<<help1, eval = FALSE>>=
? plotmath
@
and
<<help2, eval = FALSE>>=
demo (plotmath)
@

\section{Functions provided by \phy}
\label{sec:funct-prov-phy}

Table~\ref{tab:functions}~(p.~\pageref{tab:functions}) in the appendix gives an overview of the functions implemented by \phy. 

\section{Obtaining Basic Information about \Rpackage{hyperSpec} Objects}

As usual, the \Rmethod{print} and \Rmethod{show} methods display
information about the object, and \Rmethod{summary} yields some additional
details about the data handling done so far:

<<print>>=
chondro
summary (chondro)
@

The data set \Robject{chondro} consists of \Sexpr{nrow (chondro)}
spectra with \Sexpr{nwl (chondro)} data points each, and \Sexpr{ncol (chondro)}
data columns: two for the spatial information plus \Robject{\$spc}.
These informations can be directly obtained by

<<nwl>>=
nrow (chondro)
nwl (chondro)
ncol (chondro)
dim (chondro)
@

The names of the columns in \Rcode{@data} are accessed by

<<names>>=
colnames (chondro)
@

Likewise, \Rmethod{rownames} returns the names assigned to the spectra,
and \Rmethod{dimnames} yields a list of these three vectors (including
also the column names of \Robject{\$spc}).

\section{Creating a \Rclass{hyperSpec} Object, Data Import and Export}
\phy comes with filters for a variety of file formats. ASCII files are supported for import and export, Matlab files can be read and written with the help of package \Rpackage{R.matlab}. ENVI files can be read (for writing, see e.\,g. package \Rpackage{caTools}). Also reading of Thermo Galactic's .spc file format is supported.

E.\,g. to read a spectrum saved in Renishaw's ASCII file format, use:
<<scan.txt.Renishaw>>=
paracetamol <- scan.txt.Renishaw ("rawdata/paracetamol.txt", "spc")
paracetamol
save (paracetamol, file = "paracetamol.rda")
@

Vignette \texttt{FileIO} discusses the available filters and also how to derive own filters for importing  manufacturer specific data.

\subsection{Creating a \Rclass{hyperSpec} Object from Spectra Matrix
and Wavelength Vector}

If the data is in R's workspace, a \Rclass{hyperSpec} object is
created by:\\
\Rcode{spc <- new (\textquotedbl{}hyperSpec\textquotedbl{}, spc =
  spectra.matrix, wavelength = wavelength.vector, data = extra.data)}\\
You will usually give the following arguments:
\begin{description}
\setlength{\labelwidth}{2.5cm}
\setlength{\itemindent}{1.7cm}
\item [{\Rcode{spc}}] the spectra matrix
\item [{\Rcode{wavelength}}] the wavelength axis vector
\item [{\Rcode{data}}] the extra data (possibly already including the spectra matrix in column   \texttt{spc})
\item [{\Rcode{label}}] a list with the proper labels. Do not forget the
wavelength axis label in \Rcode{\$.wavelength} and the spectral intensity
axis label in \Rcode{\$spc}.
\end{description}

\section{Decomposition}
Matrix decompositions are common operations during chemometric data analysis. The results, \eg of a principal component analysis are two matrices, the so-called scores and loadings. 
The results can have either the same number of rows as the spectra matrix they were calculated from (scores-like), or they have as many wavelengths as the spectra (loadings-like).

Both types of result objects can be ``re-imported'' into \chy objects with function \Rfunction{decomposition}. A scores-like object retains all per-spectrum information (\ie the extra data) while the spectra matrix and wavelength vector are replaced. 
A loadings-like object retains the wavelength information, while extra data is deleted (set to \Rcode{NA}) unless the value is constant for all spectra.

For an example, see below (section~\ref{sec:pca} on page \pageref{sec:pca}).

\section{Combining \Rclass{hyperspec} Objects} 
\mFun{\Rfunction{\%*\%}}
\subsection{Matrix Multiplication}

Matrix multiplication is the reverse of the above mentioned decomposition.
Two \chy objects can be matrix multiplied by \Rfunction{\%*\%}. Again, this function is discussed with the principal component analysis example below (section~\ref{sec:pca} on page \pageref{sec:pca}).


\subsection{Binding Objects together}
\mFun{\Rfunction{cbind} \Rfunction{rbind}}
\label{sec:bind}
\Rclass{hyperspec} Objects can be bound together, either by rows
to append a new spectral range or by columns to append new spectra

<<cbind>>=
cbind (chondro [, , 600 ~ 800], chondro [, , 1600 ~ 1800])
rbind (chondro [, , 600 ~ 800], chondro [, , 600 ~ 800])
@

There is also a more general function, \Rfunction{bind}, taking the
direction (\Rcode{\textquotedbl{}r\textquotedbl{}} or \Rcode{\textquotedbl{}c\textquotedbl{}})
as first argument and then all objects to bind either in separate
arguments or in a list.

\section{Access to the data}

\subsection{Selecting and Deleting Spectra}

The extraction function \Rfunction{[]} (or \Rfunction{[[]]},
if the spectra \Rclass{matrix} or the \Rclass{data.frame} is needed
rather than a \Rclass{hyperSpec} object) takes the spectra as first
argument (For detailed help: \Rcode{? \textquotedbl[\textquotedbl}). It may be a vector giving the indices of the spectra to
extract (select), a vector with negative indices indicating which
spectra should be deleted, or a logical

<<delspc>>=
flu [1 : 3]
flu [-3]
chondro  [chondro$y > 10]
@

\subsection{Accessing the Extra Data }
The second argument of the extraction functions \Rfunction{[]}
and \Rfunction{[[]]} specifies the (extra) data columns.
They can be given like any column specification for a \Rclass{data.frame},
i.\,e. numeric, logical, or by a vector of the column names:

<<data>>=
colnames (chondro)
chondro [[1 : 3, 1]]
chondro [[1 : 3, -3]]
chondro [[1 : 3, "x"]]
chondro [[1 : 3, c (TRUE, FALSE, FALSE)]]
@

To select one column, the \Rcode{\$} operator is more convenient:

<<data2>>=
flu$c
@

The extra data may also be set this way:\\


<<data3>>=
flu$n <- list (1 : 6, label = "sample no.")
@

This function will append new columns, if necessary.

\subsection{Wavelengths and Spectral Axis}
\subsubsection{Wavelength Indices}\mFun{\Rfunction{wl2i} \Rfunction{i2wl}}

Spectra in \Rpackage{hyperSpec} have always discretized wavelength
axes, they are stored in a matrix with column corresponding to one
wavelength. \Rpackage{hyperSpec} provides two conversion functions:
\Rfunction{i2wl} returns the wavelength corresponding to the given
indices and \Rfunction{wl2i} calculates index vectors from wavelengths.

If the wavelengths are given as a numeric vector, they are each converted
to the corresponding wavelength. In addition there is a more sophisticated
possibility of specifying wavelength ranges using a \emph{formula}.
The basic syntax is \emph{start~}$\sim$~\emph{end.} This yields
a vector \emph{index of start }\Rcode{:}\emph{ index of end.}

The result of the formula conversion differs from the numeric vector
conversion in three ways:
\begin{itemize}
\item The colon operator for constructing vectors accepts only integer numbers,
the tilde (for formulas) does not have this restriction.
\item If the vector does not take into account the spectral resolution,
one may get only every $n^{th}$ point or repetitions of the same
index:\\
<<wl2ivec>>=
wl2i (flu, 405 : 410)
@
<<wl2ivec2>>=
wl2i (flu, 405 ~ 410)
@
<<wl2ivec3>>=
wl2i (chondro, 1000 : 1010)
@
<<wl2ivec4>>=
wl2i (chondro, 1000 ~ 1010)
@
\item If the object's wavelength axis is not ordered, the formula approach
doesn't work. In that (rare) case, use \Rfunction{orderwl} first
to obtain an object with ordered wavelength axis.
\end{itemize}
\emph{start} and \emph{end} may contain the special variables \Robject{min}
and \Robject{max} that correspond to the lowest and highest wavelengths
of the object:

<<wl2i.minmax>>=
wl2i (flu, min ~ 410)
@

Often, specifications like \emph{wavelength \textpm $n$ data points}
are needed. They can be given using complex numbers in the formula.
The imaginary part is added to the index calculated from the wavelength
in the real part:

<<wl2i.im>>=
wl2i (flu, 450 - 2i ~ 450 + 2i)
wl2i (flu, max - 2i ~ max)
@

To specify several wavelength ranges, use a list containing the formulas
and vectors\footnote{Formulas are combined to a list by \Rfunction{c}.}:

<<wl2i.list>>=
wl2i (flu, 450 - 2i ~ 450 + 2i)
wl2i (flu, c (min ~ 406.5, max - 2i ~ max))
@

This mechanism also works for the wavelength arguments of \Rfunction{[]},
\Rfunction{[[]]}, and \Rfunction{plotspc}.

%TODO Wl-Achse ändern
\subsubsection{Wavelength Axis Conversion}


\subsection{Fast Access to Parts of the \Rclass{hyperSpec} Object}\mFun{\Rfunction{[[]] \$. \$..}}

\Rclass{hyperSpec} comes with three abbreviation functions for easy
access to the data:
\begin{description}
\item [\Robject{x} \Rfunction{[[]]}] returns the spectra matrix (\Rcode{x\$spc}).
\item [\Robject{x} \Rfunction{[[\Rfunarg{i}, , \Rfunarg{l}]]}] the cut spectra matrix is returned if wavelengths are specified in \Rfunarg{l}.
\item [\Robject{x} \Rfunction{[[\Rfunarg{i}, \Rfunarg{j}, \Rfunarg{l}]]}] If data columns are selected (second index), the result is a \Rclass{data.frame}.
\item [\Robject{x} \Rfunction{[[\Rfunarg{i}, , \Rfunarg{l}]] <-}] Also, parts of the spectra matrix can be set (only indices for spectra and wavelength are allowed for this function).
\item [\Robject{x} \Rfunction{[\Rfunarg{i}, \Rfunarg{j}] <-}] sets parts of \Rcode{x@data}.
\item [\Robject{x} \Rfunction{\$.}] returns the complete \Rclass{data.frame} \Rcode{x@data}, with the spectra in column \Rcode{\$spc}.
\item [\Robject{x} \Rfunction{\$..}] returns the extra data (\Rcode{x@data} without \Rcode{x\$spc}).
\item [\Robject{x} \Rfunction{\$.. <-}] sets the extra data (\Rcode{x@data} without \Rcode{x\$spc}). However, the columns must match exactly in this case.
\end{description}


\section{Plotting}
\Rpackage{hyperSpec} comes with three predefined plotting functions.
\begin{description}
%\setlength{\labelwidth}{2.5cm}
%\setlength{\itemindent}{1.7cm}
\item [{\Rcode{plotspc}}] plots the spectra, i.~e. the intensities \Rcode{\$spc} over the wavelengths \Rcode{@wavelength}.
\item [{\Rcode{plotmap}}] plots a false colour map: a single value (e.\,g. average intensity or cluster membership) over two data columns (default \Rcode{\$x} and \Rcode{\$y}).
\item [{\Rcode{plotc}}] plots a time series or calibration plot: e.\,g. an intensity over a single other data column (like concentration, depth, or time).
\end{description}

All three plus some more handy abbreviations are also accessible via \Rmethod{plot}: \mFun{\Rfunction{plot}}

\begin{description}
%\setlength{\labelwidth}{2.4cm}
%\setlength{\itemindent}{1.7cm}
\item [{\Rcode{plot (flu, \textquotedbl{}spc\textquotedbl{})}}] is equivalent to \Rcode{plotspc (flu)}
\item [{\Rcode{plot (chondro, \textquotedbl{}spcmeansd\textquotedbl{})}}] plots mean spectrum $\pm$ 1 standard deviation
\item [{\Rcode{plot (chondro, \textquotedbl{}spcprctl\textquotedbl{})}}] plots median, 16$^{\text{th}}$ and 84$^{\text{th}}$ percentile. This is similar to \Rcode{\textquotedbl{}spcmeansd\textquotedbl{}}. Spectroscopic data frequently are not Gaussian distributed. The percentiles give a better idea of the true distribution. They are also less sensitive to outliers.
\item [{\Rcode{plot (chondro, \textquotedbl{}spcprctl5\textquotedbl{})}}] like \Rcode{\textquotedbl{}spcprctl\textquotedbl{}} plus 5$^{\text{th}}$ and 95$^{\text{th}}$percentile.
\item [{\Rcode{plot (chondro, \textquotedbl{}map\textquotedbl{})}}] is equivalent to \Rcode{plotmap (chondro)}
\item [{\Rcode{plot (flu, \textquotedbl{}c\textquotedbl{})}}] is equivalent to \Rcode{plotc (flu)}
\item [{\Rcode{plot (laser, \textquotedbl ts\textquotedbl )}}] plots a time series plot, equivalent to \Rcode{plotc (laser, use.c = \textquotedbl{}t\textquotedbl{})}
\item [{\Rcode{plot (x, \textquotedbl{}depth\textquotedbl{})}}] plots a depth profile plot, equivalent to \Rcode{plotc (laser, use.c = \textquotedbl{}z\textquotedbl{})}
\end{description}
Figure~\ref{fig:example-plots} shows some example plots.

\Rfunction{plot} uses its second argument to determine which of the
three specialized plot functions to call. All further arguments are
handed over to this function.

%
\begin{figure}
\hspace*{-0.5cm}
\setkeys{Gin}{width = .245\textwidth}
\subfloat[\label{fig-plot-spc}]{
<<plotspc, fig = TRUE, width = 4, height = 3, echo = FALSE>>=
plotspc (flu)
@
}
\subfloat[\label{fig-plot-spcmeansd}]{
<<plotspcmeansd, fig = TRUE, width = 4, height = 3, echo = FALSE>>=
plot (chondro, "spcmeansd")
@
}
\subfloat[\label{fig-plot-c}]{
<<plotc, fig = TRUE, width = 4, height = 3, echo = FALSE>>=
plotc (flu)
@
}
\subfloat[\label{fig-plot-map}]{
<<plotmap, fig = TRUE, width = 4, height = 3, echo = FALSE>>=
YG <- colorRampPalette (c ("white", "gold", "dark green"), space = "Lab")
plotmap (chondro, col.regions = YG (20))
@
}

\caption{\label{fig:example-plots}Some example plots. \subref{fig-plot-spc}\Rcode{plotspc (flu)},
\subref{fig-plot-spcmeansd}\Rcode{plot (chondro, \textquotedbl{}spcmeansd\textquotedbl{})},
\subref{fig-plot-c}\Rcode{plotc (flu)}, and \subref{fig-plot-map}\Rcode{plotmap (chondro, col.regions = YG (20))} (using a yellow-green palette).}

\end{figure}



\subsection{Plotting Spectra}\mFun{\Rfunction{plotspc}}

\Rfunction{plotspc} offers a variety of parameters for customized
plots. To plot ...
\begin{description}
\setlength{\labelwidth}{2.5cm}
\setlength{\itemindent}{1.7cm}
\item [with reversed abscissa] use \Rcode{wl.reverse = TRUE}
\item [in different colours] colours use \Rcode{col = vector.of.colours}
\item [dots instead of lines] use \Rcode{lines.args = list (pch = 20, type = \textquotedbl{}p\textquotedbl{})}
\item [mass spectra] use \Rcode{lines.args = list (type = \textquotedbl{}h\textquotedbl{})}
\item [particular wavelength ranges] use \Rcode{wl.range = list (600 \textasciitilde{} 1800, 2800 \textasciitilde{}
3100)}\\
If \Rcode{wl.range} already contains indices: use \Rcode{wl.index = TRUE}\\
Cut the wavelength axis appropriately with \Rcode{xoffset = 800}
\item [stacked spectra] use \Rfunarg{stacked}
\item [more spectra into an existing plot] use \Rcode{add = TRUE}
\item [with different line at $I =0$] use \Rcode{zeroline = \emph{list.of.arguments.to.abline}}.
\Rcode{NULL} suppresses the line.
\end{description}
<<ms, fig = TRUE, width = 8, height = 5, echo = FALSE, include = FALSE>>=
fake.mass.spec <- new ("hyperSpec", spc = matrix (100*runif (25), nrow = 1),
   wavelength = 1 : 25 + 28,
   label = list (spc = expression (e^"-" / s), .wavelength = expression (m / z)))
plot (fake.mass.spec, lines.args = list (type = "h"))
@
<<plotspcadd, fig = TRUE, width = 8, height = 5, echo = FALSE, include = FALSE>>=
plot (paracetamol, wl.range = c (300 ~ 1800, 2800 ~ max), xoffset = 850, wl.reverse = TRUE, col = "blue")
@

%
\begin{figure}
\subfloat[\label{fig-plotspc-ms}]{\includegraphics[width=0.33\textwidth]{fig/fig-ms}}%
\subfloat[\label{fig-plotspc-paracetamol}]{\includegraphics[width=0.33\textwidth]{fig/fig-plotspcadd}}%
\subfloat[\label{fig-plotmap-factor}]{\includegraphics[width=0.33\textwidth]{fig/fig-clustmap}}
\caption{Arguments to \Rfunction{plotspc}. \subref{fig-plotspc-ms}
\Rcode{plot (fake.mass.spec, lines.args = list (type = \textquotedbl{}h\textquotedbl{}))}
\subref{fig-plotspc-paracetamol} \Rcode{plotspc (paracetamol, wl.range = c (300 \textasciitilde{} 1800, 2800
\textasciitilde{} max), xoffset = 850, wl.reverse = TRUE)} \subref{fig-plotmap-factor} \Rcode{plotmap} with a factor,
see section \ref{HCA}.}
\end{figure}

\subsection{Plotting the Spectra Matrix}
\label{sec:plotmat}
It is often useful to plot the spectra against an additional coordinate, \eg the time for time series, the depth for depth profiles, etc. 

This is done by  \Rfunction{levelplot}, or by using \Rcode{plot (object, "mat", model = spc ~ .wavelength * other.data.column)}. The actual plotting is done by \Rfunction{levelplot}, so the plots can be grouped or conditioned.
See figure~\ref{fig:plotmat}
<<plotmat1, fig = TRUE, include = FALSE>>=
levelplot (spc ~ .wavelength * t, laser, col.regions = YG (20))
@
<<plotmat2, fig = TRUE, include = FALSE>>=
print (plot (flu, "mat", contour = TRUE, labels = TRUE, col = "#00000080"))
@
\begin{figure}
\subfloat[\label{fig-plotmat-a}\Rcode{levelplot (spc ~ .wavelength * t, laser, col.regions = YG (20))}]{\includegraphics[width=0.495\textwidth]{fig/fig-plotmat1}}%
\subfloat[\label{fig-plotmat-b}\Rcode{plot (flu, "mat", contour = TRUE, labels = TRUE, col = "\#00000080")}]{\includegraphics[width=0.495\textwidth]{fig/fig-plotmat2}}%
\caption{\label{fig:plotmat}plotting the spectra matrix. 
}
\end{figure}

% <<plotdef>>=
% showMethods ("plot", classes = "hyperSpec", includeDefs = TRUE)
% @
% The actual dispatching of the plots according to the second (character) argument is done by  %\Rfunction{.plot}. Thus, the new switchyard function can just act if \Rcode{y == \textquotedbl       % ms\textquotedbl}, and otherwise call \Rfunction{.plot}. As \Rfunction{.plot} is not exported from  % \phy's namespace, it must be called including its namespace.
% <<newplot>>=
% .my.mass.plot <- function (x, y, ...) {
%   if (y == "ms") {
%     dots <- list (object = x, ...)
%     dots <- modifyList (dots, list (lines.args = list (type = "h")))
%     do.call (plotspc, dots)
%   } else {
%     hyperSpec:::.plot (x, y, ...)
%   }
% }
% @ 
% Finally, \R needs to know that the new switchyard function should be used for plotting of \chy 
%  objects:
% <<setmethod>>=
% setMethod ("plot", signature (x = "hyperSpec", y = "character"), .my.mass.plot)
% @

% From now on, \Rcode{plot (x, \textquotedbl ms\textquotedbl)} will produce a plot with vertical %lines % as used for mass spectra. All other plot types are unaffected. 

% Patching \Rfunction{.plot} in \phy if the changes could be useful 



\subsection{Calibration Plots, (Depth) Profiles, and Time Series Plots}\mFun{\Rfunction{plotc}}

\Rfunction{plotc} plots an intensity over one of the extra data columns.
The abscissa uses column \Rcode{\$c} by default, another column can
be specified using \Rfunarg{use.c}\Rcode{ = name}. The ordinate can
be calculated as a sum characteristic (with parameter \Rfunarg{func}\Rcode{= function},
defaulting to \Rmethod{sum}). If parameter \Rfunarg{z} is given,
these values are used instead. \Rfunarg{z} may be the name of an extra
data column, or a \Rclass{numeric} that should be used directly.

To customize the plot, give any arguments that you would usually supply
to \Rmethod{plot} as a list using argument \Rfunarg{plot.args}.


\subsection{Plotting False-Colour Maps}\mFun{\Rfunction{plotmap}}

\Rcode{plotmap} uses \Rcode{levelplot}, a \Rpackage{lattice} function.
Therefore, in loops, functions, Sweave chunks, etc. the lattice object
needs to be printed explicitly by \Rcode{print (plotmap (object))}
(\href{http://cran.r-project.org/doc/FAQ/R-FAQ.html#Why-do-lattice_002ftrellis-graphics-not-work_003f}{R FAQ: Why do lattice/trellis graphics not work?}).

\Rfunction{plotmap} produces a 3d plot, with the $z$ axis colour-coded.
\Rfunction{plotmap}'s arguments \Rfunarg{x} and \Rfunarg{y} take
the name of extra data columns.


\paragraph{The colour-coded axis. }

Also \Rfunarg{z} can be used to select one column of the extra data
by name. Alternatively, it may be a numeric or factor directly giving
the values to be used. Each level of a factor will have one colour.
It is also possible to plot a sum characteristic of the spectra: supply
the function in argument \Rfunarg{func}. The default setting is to
plot the average intensity (no \Rfunarg{z} and \Rfunarg{func}\Rcode{= mean}).

To plot with a different palette, use \Rfunarg{trellis.args}\Rcode{= list (col.regions = palette)}.


\paragraph{Conditioning.}
Lattice graphics have a concept of conditioning a plot. Instead of
plotting all data in one diagram, a diagram is produced for each of
the groups specified by the condition. \Rfunction{plotmap}'s argument
\Rfunarg{cond} takes he name of the extra data column used for conditioning.
This could e.\,g. be a column containing the sample number of a \Rclass{hyperSpec}
object that contains several samples.


\section{Spectral (Pre)processing}
\subsection{Cutting the Spectral Range}\mFun{\Rfunction{[]} \Rfunction{[[]]}}
The extraction functions \Rfunction{[]} and \Rfunction{[[]]}
can be used to cut the spectra: Their third argument takes wavelength
specifications as discussed above and also logicals (i.e. vectors
specifying with \Rcode{TRUE}/\Rcode{FALSE} for each column of \Rcode{\$spc}
whether it should be included or not.\\
\Rfunction{[]} returns a \Rclass{hyperSpec} object, \Rfunction{[[]]}
the spectra \Rclass{matrix}\Rcode{\$spc} (or the \Rclass{data.frame}\Rcode{@data}
if data columns were specified, too) only.

<<cut.wl>>=
flu [,, min ~ 408.5]
flu [[,, c (min ~ min + 2i, max - 2i ~ max)]]
@


\subsection{Spectral Interpolation and Smoothing} \mFun{\Rfunction{spc.bin} \Rfunction{spc.loess}}
Frequently, a \Rclass{hyperSpec} object needs to be interpolated
onto a new wavelength axis. e.\,g. because measurements resulted
in slightly shifted wavelength axes. Or data from a grating spectrometer
with unequal data point spacing should be interpolated onto an evenly
spaced wavelength axis. Also, the spectra can be smoothed: reducing
the spectral resolution allows to increase the signal to noise ratio.
For chemometric data analysis reducing the number of data points per
spectrum may be crucial as it reduces the dimensionality of the data.

\Rpackage{hyperSpec} provides two functions to change the wavelength
axis of \Rclass{hyperSpec} objects: \Rfunction{spc.bin} and \Rfunction{spc.loess}.

\Rfunction{spc.bin} bins the spectral axis by averaging every \Rfunarg{by}
data points.

<<fig-loess, fig = TRUE, width = 10, height = 5, include = FALSE>>=
plot (paracetamol, wl.range = c (300 ~ 1800, 2800 ~ max), xoffset = 850)
p <- spc.loess (paracetamol, c(seq (300, 1800, 2), seq (2850, 3150, 2)))
plot (p, wl.range = c (300 ~ 1800, 2800 ~ max), xoffset = 850, col = "red", add = TRUE)
@
<<fig-loess-kl, fig = TRUE, width = 5, height = 5, include = FALSE, echo = FALSE>>=
plot (paracetamol [, , 1600 ~ 1670])
plot (p [, , 1600 ~ 1670], col = "red", add = TRUE)
@

%
\begin{figure}
\includegraphics[width=0.66\textwidth]{fig/fig-fig-loess}
\includegraphics[width=0.33\textwidth]{fig/fig-fig-loess-kl}


\captionbelow{\label{fig-spcloess}Smoothing interpolation by \Rfunction{spc.loess}
with new data point spacing of 2 cm\textsuperscript{-1}. The magnification
on the right shows how interpolation may cause a loss in signal.}
\end{figure}


\Rfunction{spc.loess} applies R's \Rfunction{loess} function for
spectral interpolation. Figure \ref{fig-spcloess} shows the result
of interpolating from 300 to 1800 and 2850 to 3150 cm\textsuperscript{-1}
with 2 cm\textsuperscript{-1} data point distance. This corresponds
to a spectral resolution of about 4 cm\textsuperscript{-1}, and the
decrease in spectral resolution can be seen at the sharp bands where
the maxima are not reached (due to the fact that the interpolation
wavelength axis does not necessarily hit the maxima. The original
spectrum had \Sexpr{nwl (paracetamol)} data points with unequal data
point spacing (between \Sexpr{signif (min (diff (wl (paracetamol))), 2)}
and \Sexpr{signif (max (diff (wl (paracetamol))), 2)} cm\textsuperscript{-1}).
The interpolated spectrum has \Sexpr{nwl (p)} data points.


\subsection{Background Correction}

To subtract a background spectrum of each of the spectra in an object,
use \Rcode{sweep (spectra, 2, background.spectrum, \textquotedbl{}-\textquotedbl{})}.


\subsection{Offset Correction}

Calculate the offsets and sweep them off the spectra:

<<ofs>>=
offsets <- apply (chondro, 1, min)
chondro.offset.corrected <- sweep (chondro, 1, offsets, "-")
@


\subsection{Baseline Correction}

\Rpackage{hyperSpec} comes with two functions to fit polynomial baselines.

\Rfunction{spc.fit.poly} fits a polynomial baseline of the given
order. A least-squares fit is done so that the function may be used
on rather noisy spectra. However, the user must supply an object that
is cut appropriately. Particularly, the supplied wavelength ranges
are not weighted.

\Rfunction{spc.fit.poly.below} tries to find appropriate support
points for the baseline iteratively.

Both functions return a \Rclass{hyperSpec} object containing the
fitted baselines. They need to be subtracted afterwards:

<<bl>>=
bl <- spc.fit.poly.below (chondro)
chondro <- chondro - bl
@

For details, see \Rcode{vignette (baselinebelow)}.


\subsection{Intensity Calibration}


\subsubsection{Correcting by a constant, e.\,g. Readout Bias}

CCD cameras often operate with a bias, causing a constant value for
each pixel. Such a constant can be immediately subtracted:\\
\Rcode{spectra - constant}


\subsubsection{Correcting Wavelength Dependence}

This means that for each of the wavelengths the same correction needs
to be applied to all spectra.
\begin{enumerate}
\item There might be wavelength dependent offsets (background or dark spectra).
They are subtracted:\\
\Rcode{sweep (spectra, 2, offset.spectrum, \textquotedbl{}-\textquotedbl{})}
\item A multiplicative dependency such as a CCD's photon efficiency: \\
\Rcode{sweep (spectra, 2, photon.efficiency, \textquotedbl{}/\textquotedbl{})}
\end{enumerate}

\subsubsection{Spectra Dependent Correction}

If the correction depends on the spectra (e.\,g. due to inhomogeneous
illumination while collecting imaging data%
\footnote{imaging (as opposed to mapping) refers to simultaneously collecting
spatially resolved spectra, either 2d images or line imaging.%
}), the \Rfunarg{MARGIN}of the \Rfunction{sweep} function needs to
be 1:
\begin{enumerate}
\item Pixel dependent offsets are subtracted:\\
\Rcode{sweep (spectra, 2, pixel.offsets, \textquotedbl{}-\textquotedbl{})}
\item A multiplicative dependency: \\
\Rcode{sweep (spectra, 2, illumination.factors, \textquotedbl{}{*}\textquotedbl{})}
\end{enumerate}

\subsection{Normalization}
\begin{enumerate}
\item Calculate appropriate normalization factors:\\
\Rcode{factors <- 1 / apply (spectra, 1, sum)} for area normalization.
\Rfunction{mean} gives equal results, just that the Intensities are
on the same scale as before.\\
For minimum-maximum-normalization, first do an offset- or baseline
correction, then calculate the \emph{\Rcode{factors}} using \Rfunction{max}.\\
You may calculate the factors using only a certain wavelength range,
thereby normalizing on a particular band or peak.
\item Again, sweep the factor off the spectra:\\
\Rcode{normalized <- sweep (spectra, 1, factors, \textquotedbl{}{*}\textquotedbl{})}
\end{enumerate}
<<norm>>=
factors <- 1 / apply (chondro, 1, mean)
chondro <- sweep (chondro, 1, factors, "*")
@


\subsection{Centering the Data}

Centering means that the mean spectrum is subtracted from each of
the spectra. Many data analysis techniques, like principal component
analysis, partial least squares, etc., work much better on centered
data.

However, from a spectroscopic point of view it depends on the particular
data set whether centering does make sense or not.

It is perfectly fine to centre the \Robject{flu} data set: the interpretation
is that centering the data cancels the offset (background spectrum
etc.) of the calibration:

<<centre-flu>>=
flu.centered <- sweep (flu, 2, apply (flu, 2, mean), "-")
@

<<fig-centre-flu, fig = TRUE, width = 10, height = 5, include = FALSE>>=
plot (flu.centered)
@

On the other hand, the \Robject{chondro} data set consists of Raman
spectra, so the spectroscopic interpretation of centering is getting
rid of the the average chemical composition of the sample. But: what
is the meaning of the {}``average spectrum'' of an inhomogeneous
sample? In this case it is better to subtract the minimum
spectrum (which will hopefully have almost the same benefit on the
data analysis) as it is the spectrum of that chemical composition
that is underlying the whole sample.

One more point to consider is that the actual minimum spectrum will
pick up lots of the negative noise. In order to avoid that, using
e.~g. the 5\textsuperscript{th} percentile spectrum is more suitable:

<<perc>>=
chondro <- sweep (chondro, 2, apply (chondro, 2, quantile, 0.05), "-")
@
<<fig-centre-ch, fig = TRUE, width = 10, height = 5, include = FALSE>>=
plot (chondro, "spcprctl5")
@


\subsection{Variance Scaling}

Variance scaling is often used in multivariate analysis to adjust
the influence and scaling of the variates (that are typically different
physical values). However, it is hardly appropriate for spectra that
do have the same scale of the same physical value.


\subsection{Multiplicative Scatter Correction (MSC)}

MSC can be done using \Rfunction{msc} from package \Rpackage{pls}\citep{Wehrens2007}.
It operates on the spectra matrix:

<<msc, eval = FALSE>>=
library (pls)
chondro.msc <- chondro
chondro.msc [[]] <- msc (chondro [[]])
@


\subsection{Spectral Arithmetic} \mFun{\Rfunction{+ - {*} / \textasciicircum{} log log10}}

Basic mathematical functions are defined for \Rclass{hyperSpec} objects.
You may convert spectra:\\
\Rcode{absorbance.spectra = - log10 (transmission.spectra)}

In this case, do not forget to adapt the label:\mFun{\Rfunction{labels}}
<<label, eval = FALSE>>=
labels (absorbance.spectra)$spc <- "A"
@

Be careful: R's \Rfunction{log} function calculates the natural
logarithm if no base is given.

The basic arithmetic operators work element-wise in R. Thus they
all need either a scalar, or a matrix (or \Rclass{hyperSpec} object)
of the correct size.

Matrix multiplication is done by \Rfunction{\%{*}\%} \mFun{\Rfunction{\%{*}\%}},
again each of the operands may be a matrix or a \Rclass{hyperSpec} object, and must have the correct dimensions.


\section{Data Analysis }
\subsection{Data Analysis Methods using a data.frame \\
e.\,g. Principal Component Analysis with \Rfunction{prcomp}}
\label{sec:pca}
The \Rcode{\$.} notation is handy, if a data analysis function expects
a \Rclass{data.frame}. The column names can then be used in the formula:

<<pca>>=
pca <- prcomp (~ spc, data = chondro$., center = FALSE)
@

Results of such a decomposition can be put again into \Rclass{hyperSpec}
objects. This allows to plot \eg the loading like spectra, or score
maps, see figure~\ref{fig:pca}.

<<decomp>>=
scores <- decomposition (chondro, pca$x, label.wavelength = "PC", 
                         label.spc = "score / a.u.")
scores
@ 

The loadings can be similarly re-imported:
<<loadings>>=
loadings <- decomposition (chondro, t(pca$rotation), scores = FALSE, 
                           label.spc = "loading I / a.u.")
loadings
@
There is, however, one important difference. The loadings are thought of as values computed from all spectra togehter. Thus no meaningful extra data can be assigned for the loadings object (at least not if the column consists of different values). Therefore, the loadings object lost all extra data (see above). 

\Rfunarg{retain.columns} triggers whether columns that contain different values should be dropped. If it is set to \Rcode{TRUE}, the columns are retained, but contain \Rcode{NA}s:
<<retain.col>>=
loadings <- decomposition (chondro, t(pca$rotation), scores = FALSE, 
                           retain.columns = TRUE, label.spc = "loading I / a.u.")
loadings[1]$..
@
If an extra data column does contain only one unique value, it is retained anyways:
<<retain>>=
chondro$measurement <- 1
loadings <- decomposition (chondro, t(pca$rotation), scores = FALSE, 
                           label.spc = "loading I / a.u.")
loadings[1]$..
@
\begin{figure}
\setkeys{Gin}{width = .495\textwidth}
\subfloat[\label{fig-pca-load}]{
<<pca-load, fig = TRUE, width = 8, height = 5, echo = FALSE>>=
plot (loadings [1:3], stacked = TRUE)
@
}
\subfloat[\label{fig-pca-score}]{
<<pca-score, fig = TRUE, width = 8, height = 5, echo = FALSE>>=
plotmap (scores [,,2], col.regions = div.palette (20))
@
}
\caption{\label{fig:pca}
  \subref{fig-pca-load} The first three loadings: \Rcode{plot (loadings [1 : 3], stacked = TRUE)}.  
  \subref{fig-pca-score} The second score map: \Rcode{plotmap (scores [, , 2])}}.
\end{figure}

\subsubsection{PCA as Noise Filter}
\label{sec:pca-as-noise}
Principal component analysis is sometimes used as a noise filtering technique. The idea is that the relevant differences are captured in the first components while the higher components contain noise only. Thus the spectra are reconstructed using only the first $p$ components.

This reconstruction is in fact a matrix multiplication:
\[ spectra^{(nrow \times nwl)} = scores^{(nrow \times p)} loadings^{(p \times nwl)} \]
Note that this corresponds to a model based on the Beer-Lambert law:
\[ A_n (\lambda) = c_{n,i} \epsilon (i, \lambda) + error \]
The matrix formulation puts the $n$ spectra into the rows of $A$ and $c$, while the $i$ pure components appear in the columns of $c$ and rows of the absorbance coefficients $\epsilon$.

For an ideal data set (constituents varying independently, sufficient signal to noise ratio) one would expect the principal component analysis to extract something like the concentrations and pure component spectra.

If we decide that only the first 10 components actually carry spectroscopic information, we can reconstruct spectra with better signal to noise ratio:
<<pca-smooth>>=
smoothed <- scores [,, 1:10] %*% loadings [1:10]
@
Keep in mind, though, that we cannot be sure how much \emph{useful} information was discarded with the higher components. This kind of noise reduction may influence further modeling of the data. Mathematically speaking, the rank of the 
\Sexpr{nrow (chondro)} $\times$ \Sexpr{nwl (chondro)} spectra matrix was reduced to 10.

\subsection{Data Analysis Methods using a matrix \\
e.\,g. Hierarchical Cluster Analysis\label{HCA}}

<<hca>>=
dist <- pearson.dist (chondro [[]])
dendrogram <- hclust (dist, method = "ward")
@
<<dend, fig = TRUE, width = 5, height = 5, include = FALSE>>=
plot (dendrogram)
@

In order to plot a cluster map, the cluster membership needs to be
calculated from the dendrogram.

First, cut the dendrogam so that three clusters result:

<<dendcut>>=
chondro$clusters <- as.factor (cutree (dendrogram, k = 3))
@
As the cluster membership was stored as factor, the levels can be meaningful names, which are displayed in the color legend.
<<clustname>>=
levels (chondro$clusters) <- c ("matrix", "lacuna", "cell")
@
Then the result may be plotted (figure~\ref{fig:clust:map}):
<<clustmap, fig = TRUE, width = 7.5, height = 5, include = FALSE, echo = FALSE>>=
cluster.cols <- c ("dark blue", "orange", "#C02020")
plotmap (chondro, clusters ~ x * y, col.regions = cluster.cols)
@

%
\begin{figure}
\subfloat[\label{fig:clust:dend}]{\includegraphics[width=0.33\textwidth]{fig/fig-dend}}
\subfloat[\label{fig:clust:map}]{\includegraphics[width=0.33\textwidth]{fig/fig-clustmap}}
\subfloat[\label{fig:clust:spc}]{\includegraphics[width=0.33\textwidth]{fig/fig-clustmean}}
\caption{The results of the cluster analysis: \subref{fig:clust:dend} the
dendrogram \subref{fig:clust:map} the map of the 3 clusters \subref{fig:clust:spc}
the mean spectra.}
\end{figure}

\subsection{Calculating group-wise Sum Characteristics \\
e.\,g. Cluster Mean Spectra}

\Rfunction{aggregate} applies the function given in \Rfunarg{FUN}
to each of the groups of spectra specified in \Rfunarg{by}. \mFun{\Rfunction{aggregate}}

So we may plot the cluster mean spectra:

<<clustmean, fig = TRUE, width = 7.5, height = 5, include = FALSE>>=
means <- aggregate (chondro, by = chondro$clusters, mean_pm_sd)
plot (means, col = cluster.cols, stacked = ".aggregate", fill = ".aggregate")
@


\subsection{Splitting an Object}

A \Rclass{hyperSpec} object may also be split into a list of \Rclass{hyperSpec}
objects:

<<split>>=
clusters <- split (chondro, chondro$clusters)
clusters
@

Splitting can be reversed by \Rfunction{rbind} (see section~\ref{sec:bind}, page~\pageref{sec:bind}).

\bibliographystyle{unsrtnat}
\bibliography{introduction}

\appendix
\section{Overview of the functions provided by \phy}
\label{tab:functions}

\begin{small}
\renewcommand{\arraystretch}{1.5}
\begin{longtable}{>{\raggedright}p{0.3\textwidth}p{0.65\textwidth}}
\toprule
\textbf{Function} & \textbf{Explanation}\\
\cmidrule(lr){1-1}\cmidrule(lr){2-2}
\endhead
<<tab-fn, results = tex, echo = FALSE>>=
make.fn.table <- function (){
load ("functions.RData")
functions <- subset (functions, !internal)
functions$group <- functions$group[,drop=TRUE]

TeX.escape <- function (x){
#  x <- gsub ("^\\\\([^\\\\])", "\\\\\\\\\\1", x)
#  x <- gsub ("[^\\\\]\\\\$", "\\1\\\\\\\\", x)
  x <- gsub ("([^\\\\]|^)\\$", "\\1\\\\$", x)
  x <- gsub ("([^\\\\]|^)_", "\\1\\\\_", x)
  x <- gsub ("([^\\\\]|^)%", "\\1\\\\%", x)
  x
}

for (g in levels (functions$group)){
  cat ("\\multicolumn{2}{l}{\\emph{",g, "}}\\\\\n", sep = "")
  df <- t (functions [functions$group == g, c ("name", "description")])
  cat (paste (paste ("\\verb+", df[1,], "+", sep = ""), df[2,], sep = " & ", collapse ="\\\\\n"),"\\\\\n")
}
}
make.fn.table()
@
\bottomrule
\end{longtable}
\end{small}

<<cleanup, echo = FALSE, results = hide>>=
rm (list = ls () )
@
\end{document}
