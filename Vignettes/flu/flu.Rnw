\documentclass[a4paper, 10pt, smallheadings, DIV15]{scrartcl}
\usepackage[utf8]{inputenc}
%\VignetteIndexEntry{flu}
\usepackage{xspace}
\usepackage{hyphenat}
\usepackage{fancyvrb}
%\usepackage{SIunitx}

\newcommand{\rcm}[1]{\ensuremath{#1\;\mathrm{cm^{-1}}}\xspace}
\newcommand{\code}[1]{\nohyphens{\texttt{#1}}\xspace}
\newcommand{\hy}{\nohyphens{\texttt{hyperSpec}}\xspace}
\newcommand{\R}{\texttt{R}\xspace}

\author{C.~Beleites, DMRN, Universit√† degli Studi di Trieste, Trieste/I}
\title{Calibration of Quinine Fluorescence Emission\\
Vignette for the Data Set \code{flu} of the R package \hy}
 

\begin{document}
\fvset{listparameters={\setlength{\topsep}{0pt}}}
\renewenvironment{Schunk}{\vspace{\topsep}\begin{small}}{\end{small}\vspace{\topsep}}
<<echo = FALSE, results = hide>>=
options(SweaveHooks=list(fig=function() par(mar = c (3.6, 3.6, .6, .6))))
options ("width" = 100)
@
\maketitle

This vignette gives an example how to 
\begin{itemize}
\item write an import function for a spectrometer manufacturer's proprietary ASCII files,
\item add further data columns to the spectra, and  
\item set up a linear calibration (inverse least squares).
\end{itemize}

The data set \code{flu} in \hy consists of 6 fluorescence emission spectra of quinine solutions. 
They were acquired during an student practicum and were kindly provided by M. Kammer. 

The concentrations of the solutions range from 0.05 mg/l to 0.30 mg/l. Spectra were acquired with a 
Perkin Elmer LS50-B fluorescence spectrometer at 350 nm excitation.

In order to work with \hy, the library needs to be loaded in \R:
<<init>>=
library (hyperSpec)
@

\section{Writing an Import Function}
Now we need to import the spectra. They are in Perkin Elmer's ASCII file format, 
one spectrum per file. The files are completely ASCII text, with the actual spectra starting at line 55.

The function should automatically read in all files specified by a pattern, such as \code{*.txt}. 
In order to gain some speed, the spectra matrix is preallocated after the first file is read. 
Also, the number of header lines are predefined instead of searching for the line after \texttt{#DATA}. 

Note, that labels giving the correct units (e.g. for axis labels) are set. The label 
with the special name \code{.wavelength} corresponds to the wavelength axis, all data columns should 
have a label with the same name. The spectra are always in a data column called \code{spc}.

<<importfun>>=
read.PE <- function (files = "*.txt", skip = 54) {
	files <- Sys.glob (files)
	
	buffer <- matrix (scan (files [1], skip = skip), ncol = 2, byrow = TRUE)
	
	wavelength <- buffer [, 1]
	spc <- matrix (ncol = nrow (buffer), nrow = length (files)) 
	
	spc [1, ] <-  buffer [, 2]
	
	for (f in seq (along = files)[-1]) {

		buffer <- matrix (scan (files [f], skip = skip), ncol = 2, byrow = TRUE)
		
		if (! all.equal (buffer [, 1], wavelength))
			stop (paste(files [f], "has different wavelengh axis."))
		
		spc [f, ] <- buffer[, 2]
	}
	
	new ("hyperSpec", wavelength = wavelength, spc = spc,
			label = list (.wavelength = expression (lambda[fl] / nm),
					spc = "I / a.u."))
}
@
From now on, the function can be used:
<<import>>=
flu <- read.PE ("*.txt")
@
Now the spectra are in a hyperSpec object and can be examined e.g. by
<<rawspc>>=
flu
@
\setkeys{Gin}{width = \textwidth}
<<rawfig, fig = TRUE, width = 10, height = 5>>=
plot (flu)
@
\section{Adding further Data Coumns}
The calibration model needs the quinine concentrations for the spectra. 
This information can be stored together with the specta, and also gets an appropriate label:
<<>>=
flu$c <- seq (from = 0.05, to = 0.30, by = 0.05)
labels (flu, "c") <- "c / (mg / l)"
flu
@

Now the \hy object \code{flu} contains two data columns, holding the actual spectra and the 
respective concentrations\footnote{}. The dollar operator returns such a data column:
<<>>=
flu$c
@

\section{Linear Calibration}
As \R is developed for the purpose of statistical analysis, tools for a least squares calibration 
model are readily availabe.

The original spectra range from \SExpr{min(wl(flu))} to \SExpr{max(wl(flu))} nm. 
However, the intensities at 445 nm are perfect for a univariate calibration. Plotting them over the 
concentration is done by
\setkeys{Gin}{width = .5\textwidth}
<<calplot1, fig=TRUE, pdf = TRUE, echo = FALSE, eps = FALSE, width = 6, height = 6>>=
plotc (flu[,,445])
@
The square bracket operator extracts parts of a \hy object. 
The first coordinate defines which spectra are to be used, the second which data columns, and the 
third gives the spectral range.

We discard all the wavelengths but 445 nm:
<<>>=
	flu <- flu [,,445]
@

The plot could be enhanced by annotating the ordinate with the emission wavelength. 
Also the axes should start at the origin, so that it is easier to see whether the calibration 
function will go through the origin:   
\setkeys{Gin}{width = .5\textwidth}
<<calplot2, fig=TRUE, pdf = TRUE, echo = FALSE, eps = FALSE, width = 6.5, height = 6.5>>=
plotc (flu,
	   zlab = expression (I ["450 nm"] / a.u.),
	   plot.dots = list (xlim = range (0, flu$c), ylim = range (0, flu$spc))
	)
@

The actual calibration is a linear model, which can be fitted by dhe \R function \code{lm}. 
As \code{lm} needs a \emph{formula} that specifies which data columns are dependent and independent 
variables and expects the data to be in a \code{data.frame}.

The normal calibration plot gives the emission intensity as a function of the concentration, and 
the calibration function thus models $I = f (c)$, i. e.  $I = m c + b$ for a linear calibration. 
This is then solved for $c$ when the calibration is used. 

However, \R's linear model is a bit strict in predicting: a model set up as $I = f (c)$ will predict 
the intensity as a function of the concentration but not the other way round. Thus we set up an 
inverse calibration model\footnote{As we can safely assume that the error on the concentrations is 
far larger than the error on the instrument signal, it is actually the correct type of model from 
the least squares fit point of view.}:  $c = f (I)$. The corresponding formula is \code{c \~ I}, or in our case 
\code{c \~ spc}, as the intensitie ar estored in the data column \code{spc}:

There are three abbrevations that help to get the parts  of the \hy object that are frequently  needed:
\begin{description}
 \item[\code{flu[[]]}] returns the spectra matrix. It takes the same indices as \code{[]}.
 \item[\code{flu\$.}] returns the data as a \code{data.frame}
 \item[\code{flu\$..}] returns a  \code{data.frame} that has all data columns but the spectra
\end{description}
<<>>=
	flu[[]]   
	flu$.
	flu$..
@

Putting this together, the calibration model is calculated:
<<>>=
calibration <- lm (c ~ spc, data = flu$.)
@

The \code{summary} gives a good overview of our model:
<<>>=
summary (calibration)
@

In order to get predictions for new measurements, 

The resulting calibration function and the 99.9 \% confidence interval\footnote{lower confidence 
levels are hardly to be distinguished from the calibration line} can be drawn.

<<calplot3, fig=TRUE, pdf = TRUE, echo = FALSE, eps = FALSE, width = 6.5, height = 6.5>>=
plotc (flu,
		zlab = expression (I ["450 nm"] / a.u.),
		plot.dots = list (xlim = range (0, flu$c), ylim = range (0, flu$spc))
)

int <- list (spc = as.matrix(min (flu) : max(flu)))
ci <- predict (calibration, newdata = int, interval = "confidence", level = 0.999) 
matlines (ci, int$spc, col = c ("red","#606060","#606060"), lty = 1)

# extrapolate to lower intensities
int <- list (spc = as.matrix(0 : min (flu)))
ci <- predict (calibration, newdata = int, interval = "confidence", level = 0.999) 
matlines (ci, int$spc, col = c ("red","#606060","#606060"), lty = 3)
@
  




  

\end{document}


